# Memento Mori - Project Rules

## Language Policy

- **All code, comments, documentation, commit messages, and PR descriptions MUST be in English**
- This is an international project with an English-speaking team
- User communication in chat may be in Russian, but all generated code/docs must be English
- Use American English spelling (e.g., "color" not "colour", "organize" not "organise")

---

## Project Overview

Memento Mori is a marketplace platform for funeral services connecting clients with verified vendors.

### Tech Stack
- **Backend:** NestJS 10, Prisma 6, PostgreSQL 15, Redis
- **Frontend:** Next.js 14 (App Router), React 18, TypeScript 5
- **Styling:** Tailwind CSS 3.4, Radix UI primitives
- **Auth:** Keycloak (IdP) - handles all authentication
- **Payments:** Stripe Connect
- **i18n:** next-intl
- **Testing:** Jest, Supertest, React Testing Library

### Project Structure
```
apps/
├── server/          # NestJS Backend API (port 3001)
├── client/          # Next.js Client App (port 3000)
├── vendor-portal/   # Next.js Vendor Portal (port 3002)
└── admin-portal/    # Next.js Admin Portal (port 3003)
packages/
└── shared/          # Shared types, constants, utilities
```

---

## Code Style & Conventions

### General TypeScript Rules
- Use TypeScript strict mode (`"strict": true`)
- Prefer `interface` over `type` for object shapes
- Use `type` for unions, intersections, and mapped types
- Always define return types for functions
- Use `readonly` for immutable properties
- Avoid `any` - use `unknown` if type is truly unknown
- Use optional chaining (`?.`) and nullish coalescing (`??`)

```typescript
// ✅ Good
interface User {
  readonly id: string;
  email: string;
  firstName?: string;
}

function getUser(id: string): Promise<User | null> {
  // ...
}

// ❌ Bad
type User = {
  id: any;
  email: string;
}

function getUser(id) {
  // ...
}
```

### Naming Conventions
- **Files:** kebab-case (`user-profile.service.ts`, `auth.guard.ts`)
- **Classes:** PascalCase (`UserService`, `AuthGuard`)
- **Interfaces:** PascalCase, NO "I" prefix (`User`, not `IUser`)
- **Types:** PascalCase (`UserRole`, `OrderStatus`)
- **Functions/Methods:** camelCase (`getUserById`, `validateToken`)
- **Variables:** camelCase (`isLoading`, `userCount`)
- **Constants:** SCREAMING_SNAKE_CASE (`MAX_RETRY_COUNT`, `API_BASE_URL`)
- **Enums:** PascalCase for name, SCREAMING_SNAKE_CASE for values

```typescript
// ✅ Good
enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  COMPLETED = 'COMPLETED',
}

const MAX_PAGE_SIZE = 100;

// ❌ Bad
enum orderStatus {
  pending = 'pending',
}
```

---

## Backend (NestJS) Standards

### Module Structure
Each feature module should follow this structure:
```
feature/
├── dto/
│   ├── create-feature.dto.ts
│   ├── update-feature.dto.ts
│   └── feature-response.dto.ts
├── entities/
│   └── feature.entity.ts
├── feature.controller.ts
├── feature.service.ts
├── feature.module.ts
└── feature.spec.ts
```

### DTOs (Data Transfer Objects)
- Always use class-validator decorators for validation
- Use class-transformer for transformation
- Separate Create, Update, and Response DTOs
- Document with Swagger decorators

```typescript
// ✅ Good: dto/create-user.dto.ts
import { IsEmail, IsString, MinLength, IsOptional } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty({ example: 'user@example.com', description: 'User email address' })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  email: string;

  @ApiProperty({ example: 'SecureP@ss123', minLength: 8 })
  @IsString()
  @MinLength(8, { message: 'Password must be at least 8 characters' })
  password: string;

  @ApiPropertyOptional({ example: 'John' })
  @IsOptional()
  @IsString()
  firstName?: string;
}
```

### Controllers
- Use proper HTTP status codes
- Document all endpoints with Swagger
- Use guards for authentication/authorization
- Keep controllers thin - business logic in services

```typescript
// ✅ Good
@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new user' })
  @ApiResponse({ status: 201, description: 'User created successfully', type: UserResponseDto })
  @ApiResponse({ status: 400, description: 'Validation error' })
  @ApiResponse({ status: 409, description: 'Email already exists' })
  async create(@Body() createUserDto: CreateUserDto): Promise<UserResponseDto> {
    return this.usersService.create(createUserDto);
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get user by ID' })
  @ApiResponse({ status: 200, type: UserResponseDto })
  @ApiResponse({ status: 404, description: 'User not found' })
  async findOne(@Param('id', ParseUUIDPipe) id: string): Promise<UserResponseDto> {
    return this.usersService.findOne(id);
  }
}
```

### Services
- Handle business logic
- Use transactions for multi-step operations
- Throw appropriate NestJS exceptions
- Keep methods focused (single responsibility)

```typescript
// ✅ Good
@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  async create(dto: CreateUserDto): Promise<User> {
    const existingUser = await this.prisma.user.findUnique({
      where: { email: dto.email.toLowerCase() },
    });

    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    const hashedPassword = await bcrypt.hash(dto.password, 12);

    return this.prisma.user.create({
      data: {
        ...dto,
        email: dto.email.toLowerCase(),
        password: hashedPassword,
      },
    });
  }
}
```

### Error Handling
- Use NestJS built-in exceptions
- Create custom exceptions for domain-specific errors
- Always include meaningful error messages

```typescript
// HTTP Exceptions to use:
// 400 - BadRequestException (validation errors)
// 401 - UnauthorizedException (not authenticated)
// 403 - ForbiddenException (not authorized)
// 404 - NotFoundException (resource not found)
// 409 - ConflictException (duplicate resource)
// 422 - UnprocessableEntityException (business logic error)
// 500 - InternalServerErrorException (unexpected errors)
```

### Authentication with Keycloak
The project uses **Keycloak** as Identity Provider (IdP). This means:
- ✅ Keycloak handles user registration, login, password storage
- ✅ Keycloak issues JWT tokens (access_token, refresh_token)
- ✅ Backend only validates tokens using Keycloak's public key
- ✅ No custom auth code needed - use `nest-keycloak-connect`
- ✅ MFA, OAuth, social login available out of the box

```typescript
// Backend just validates Keycloak tokens
import { AuthGuard, Resource, Roles } from 'nest-keycloak-connect';

@Controller('orders')
@Resource('orders')
export class OrdersController {
  @Get()
  @Roles({ roles: ['user', 'admin'] })
  @UseGuards(AuthGuard)
  async findAll() {
    // User is already authenticated by Keycloak
  }
}
```

### Security Requirements
- **NEVER** implement custom auth - use Keycloak
- **NEVER** store passwords in application database
- **ALWAYS** validate Keycloak tokens on every request
- **ALWAYS** validate and sanitize user input
- **ALWAYS** use parameterized queries (Prisma handles this)
- **NEVER** expose sensitive data in responses (internal IDs, tokens)
- **ALWAYS** use HTTPS in production
- **ALWAYS** configure proper CORS for Keycloak redirects

---

## Frontend (Next.js) Standards

### Component Structure
```
components/
├── ui/                    # Primitive UI components (Button, Input, Card)
├── forms/                 # Form components
├── layout/                # Layout components (Header, Footer, Sidebar)
└── features/              # Feature-specific components
    └── orders/
        ├── OrderCard.tsx
        ├── OrderList.tsx
        └── index.ts
```

### Component Guidelines
- Use functional components with hooks
- Prefer Server Components when possible (Next.js 14)
- Use 'use client' directive only when necessary
- Keep components small and focused (< 200 lines)
- Extract logic into custom hooks

```typescript
// ✅ Good: Server Component (default)
// app/users/page.tsx
import { getUsers } from '@/lib/api';

export default async function UsersPage() {
  const users = await getUsers();
  
  return (
    <div>
      <h1>Users</h1>
      <UserList users={users} />
    </div>
  );
}

// ✅ Good: Client Component (when needed)
// components/features/users/UserSearch.tsx
'use client';

import { useState } from 'react';

interface UserSearchProps {
  onSearch: (query: string) => void;
}

export function UserSearch({ onSearch }: UserSearchProps) {
  const [query, setQuery] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch(query);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* ... */}
    </form>
  );
}
```

### State Management
- Use React Query (TanStack Query) for server state
- Use React Context for global UI state (theme, language)
- Use useState/useReducer for local component state
- Avoid prop drilling - use composition or context

### Styling with Tailwind CSS
- Use Tailwind utility classes
- Create reusable components instead of @apply
- Use CSS variables for theme colors
- Follow mobile-first responsive design

```typescript
// ✅ Good
<button className="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">
  Submit
</button>

// ❌ Bad - Don't create utility classes with @apply
// styles.css
// .btn-primary { @apply px-4 py-2 bg-primary... }
```

### Accessibility (a11y)
- Use semantic HTML elements
- Include proper ARIA labels
- Ensure keyboard navigation
- Maintain color contrast ratios (WCAG 2.1 AA)
- Test with screen readers

```typescript
// ✅ Good
<button
  aria-label="Close dialog"
  onClick={onClose}
  className="..."
>
  <XIcon aria-hidden="true" />
</button>

// ❌ Bad
<div onClick={onClose}>X</div>
```

---

## Database (Prisma) Standards

### Schema Conventions
- Use camelCase for field names
- Use PascalCase for model names
- Always include `createdAt` and `updatedAt`
- Use `@@map` for snake_case table names
- Add comments for complex fields

```prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String   /// Hashed with bcrypt, never store plain text
  role      Role     @default(CLIENT)
  firstName String?  @map("first_name")
  lastName  String?  @map("last_name")
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  orders Order[]
  
  @@map("users")
  @@index([email])
}
```

### Migrations
- Always use descriptive migration names
- Review generated SQL before applying
- Never edit migrations after they're applied to production

```bash
# Good migration names
npx prisma migrate dev --name add_user_profile_fields
npx prisma migrate dev --name create_orders_table
npx prisma migrate dev --name add_index_on_user_email
```

---

## Testing Standards

### Unit Tests
- Test file naming: `*.spec.ts` or `*.test.ts`
- One test file per module/component
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)

```typescript
// ✅ Good
describe('UsersService', () => {
  describe('create', () => {
    it('should create a user with hashed password', async () => {
      // Arrange
      const dto = { email: 'test@example.com', password: 'password123' };
      
      // Act
      const result = await service.create(dto);
      
      // Assert
      expect(result.email).toBe('test@example.com');
      expect(result.password).not.toBe('password123');
    });

    it('should throw ConflictException when email already exists', async () => {
      // ...
    });
  });
});
```

### E2E Tests
- Test critical user flows
- Use test database
- Clean up data after tests

### Coverage Requirements
- Aim for >80% coverage on core business logic
- 100% coverage on auth and payment modules
- Don't test trivial getters/setters

---

## Git Conventions

### Branch Naming
```
feature/MM-123-user-authentication
bugfix/MM-456-fix-payment-processing
hotfix/MM-789-security-patch
refactor/MM-012-optimize-queries
```

### Commit Messages
Follow Conventional Commits with scope:

```
feat(auth): implement JWT authentication with refresh tokens
fix(orders): resolve race condition in payment processing
docs(api): add Swagger documentation for users endpoint
refactor(prisma): optimize user queries with indexes
test(auth): add unit tests for token validation
chore(deps): upgrade NestJS to v10.3
```

### Pull Request Guidelines
- Keep PRs focused and small (< 400 lines when possible)
- Include tests for new features
- Update documentation if needed
- Request review from CODEOWNERS
- Squash commits before merging

---

## API Design Standards

### RESTful Conventions
- Use plural nouns for resources (`/users`, `/orders`)
- Use HTTP methods correctly (GET, POST, PUT, PATCH, DELETE)
- Use proper status codes
- Version API in URL (`/api/v1/users`)

### Response Format
```typescript
// Success response
{
  "success": true,
  "data": { /* ... */ },
  "meta": {
    "page": 1,
    "limit": 20,
    "total": 100,
    "totalPages": 5
  }
}

// Error response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [
      { "field": "email", "message": "Invalid email format" }
    ]
  },
  "timestamp": "2025-12-02T10:00:00.000Z",
  "path": "/api/v1/users"
}
```

---

## Performance Guidelines

### Backend
- Use database indexes for frequently queried fields
- Implement pagination for list endpoints
- Use Redis for caching frequently accessed data
- Use connection pooling for database
- Implement request timeouts

### Frontend
- Use Next.js Image component for images
- Implement lazy loading for below-fold content
- Use React.memo for expensive components
- Minimize client-side JavaScript
- Use Suspense for loading states

---

## Environment Variables

### Naming Convention
- Use SCREAMING_SNAKE_CASE
- Prefix with service name for clarity
- Never commit secrets to repository

```env
# Database
DATABASE_URL=postgresql://user:pass@localhost:5432/db

# Auth
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=24h

# External Services
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Email
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=user
SMTP_PASSWORD=password
```

---

## Documentation Requirements

- All public APIs must have Swagger documentation
- Complex functions need JSDoc comments
- README files for each app/package
- Architecture Decision Records (ADRs) for major decisions
- Keep documentation up to date with code changes

---

## Prohibited Patterns

### Never Do This:
- ❌ Implement custom authentication - use Keycloak
- ❌ Store passwords in application database
- ❌ Use `any` type without justification
- ❌ Commit secrets or API keys
- ❌ Use `console.log` in production code (use proper logger)
- ❌ Disable TypeScript strict mode
- ❌ Skip error handling
- ❌ Use synchronous file operations in API handlers
- ❌ Hardcode configuration values
- ❌ Use `eval()` or `new Function()`
- ❌ Trust user input without validation
- ❌ Use `innerHTML` with user content (XSS risk)
- ❌ Store sensitive data in localStorage
- ❌ Store tokens in localStorage (use httpOnly cookies or memory)

---

## Required Packages

### Backend (must be installed)
```json
{
  "@nestjs/swagger": "^7.x",
  "nest-keycloak-connect": "^1.x",
  "keycloak-connect": "^24.x",
  "class-validator": "^0.14.x",
  "class-transformer": "^0.5.x",
  "helmet": "^7.x",
  "@nestjs/throttler": "^5.x"
}
```

> **Note:** No need for `@nestjs/jwt`, `@nestjs/passport`, `bcrypt` - Keycloak handles all authentication.

### Frontend (must be installed)
```json
{
  "@tanstack/react-query": "^5.x",
  "zod": "^3.x",
  "react-hook-form": "^7.x",
  "@hookform/resolvers": "^3.x"
}
```

---

## IDE Setup

### Recommended VS Code Extensions
- ESLint
- Prettier
- Prisma
- Tailwind CSS IntelliSense
- TypeScript Hero
- GitLens

### Settings
```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
    "source.organizeImports": true
  }
}
```
