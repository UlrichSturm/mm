"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/keycloak-js";
exports.ids = ["vendor-chunks/keycloak-js"];
exports.modules = {

/***/ "(ssr)/../../node_modules/keycloak-js/lib/keycloak.js":
/*!******************************************************!*\
  !*** ../../node_modules/keycloak-js/lib/keycloak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   \"default\": () => (/* binding */ Keycloak)\n/* harmony export */ });\n// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json'\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\n\nclass Keycloak {\n  /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n  #refreshQueue = []\n  /** @type {KeycloakAdapter} */\n  #adapter\n  /** @type {boolean} */\n  #useNonce = true\n  /** @type {CallbackStorage} */\n  #callbackStorage\n  #logInfo = this.#createLogger(console.info)\n  #logWarn = this.#createLogger(console.warn)\n  /** @type {LoginIframe} */\n  #loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  }\n\n  /** @type {KeycloakConfig} config */\n  #config\n  didInitialize = false\n  authenticated = false\n  loginRequired = false\n  /** @type {KeycloakResponseMode} */\n  responseMode = 'fragment'\n  /** @type {KeycloakResponseType} */\n  responseType = 'code'\n  /** @type {KeycloakFlow} */\n  flow = 'standard'\n  /** @type {number?} */\n  timeSkew = null\n  /** @type {string=} */\n  redirectUri\n  /** @type {string=} */\n  silentCheckSsoRedirectUri\n  /** @type {boolean} */\n  silentCheckSsoFallback = true\n  /** @type {KeycloakPkceMethod} */\n  pkceMethod = 'S256'\n  enableLogging = false\n  /** @type {'GET' | 'POST'} */\n  logoutMethod = 'GET'\n  /** @type {string=} */\n  scope\n  messageReceiveTimeout = 10000\n  /** @type {string=} */\n  idToken\n  /** @type {KeycloakTokenParsed=} */\n  idTokenParsed\n  /** @type {string=} */\n  token\n  /** @type {KeycloakTokenParsed=} */\n  tokenParsed\n  /** @type {string=} */\n  refreshToken\n  /** @type {KeycloakTokenParsed=} */\n  refreshTokenParsed\n  /** @type {string=} */\n  clientId\n  /** @type {string=} */\n  sessionId\n  /** @type {string=} */\n  subject\n  /** @type {string=} */\n  authServerUrl\n  /** @type {string=} */\n  realm\n  /** @type {KeycloakRoles=} */\n  realmAccess\n  /** @type {KeycloakResourceAccess=} */\n  resourceAccess\n  /** @type {KeycloakProfile=} */\n  profile\n  /** @type {{}=} */\n  userInfo\n  /** @type {Endpoints} */\n  endpoints\n  /** @type {number=} */\n  tokenTimeoutHandle\n  /** @type {() => void=} */\n  onAuthSuccess\n  /** @type {(errorData?: KeycloakError) => void=} */\n  onAuthError\n  /** @type {() => void=} */\n  onAuthRefreshSuccess\n  /** @type {() => void=} */\n  onAuthRefreshError\n  /** @type {() => void=} */\n  onTokenExpired\n  /** @type {() => void=} */\n  onAuthLogout\n  /** @type {(authenticated: boolean) => void=} */\n  onReady\n  /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n  onActionUpdate\n\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor (config) {\n    if (typeof config !== 'string' && !isObject(config)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\")\n    }\n\n    if (isObject(config)) {\n      const requiredProperties = 'oidcProvider' in config\n        ? ['clientId']\n        : ['url', 'realm', 'clientId']\n\n      for (const property of requiredProperties) {\n        if (!(property in config)) {\n          throw new Error(`The configuration object is missing the required '${property}' property.`)\n        }\n      }\n    }\n\n    if (!globalThis.isSecureContext) {\n      this.#logWarn(\n        \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n                'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' +\n                'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts'\n      )\n    }\n\n    this.#config = config\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  async init (initOptions = {}) {\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\")\n    }\n\n    this.didInitialize = true\n    this.#callbackStorage = createCallbackStorage()\n\n    const adapters = ['default', 'cordova', 'cordova-native']\n\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      this.#adapter = this.#loadAdapter(initOptions.adapter)\n    } else if (typeof initOptions.adapter === 'object') {\n      this.#adapter = initOptions.adapter\n    } else if ('Cordova' in window || 'cordova' in window) {\n      this.#adapter = this.#loadAdapter('cordova')\n    } else {\n      this.#adapter = this.#loadAdapter('default')\n    }\n\n    if (typeof initOptions.useNonce !== 'undefined') {\n      this.#useNonce = initOptions.useNonce\n    }\n\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      this.#loginIframe.enable = initOptions.checkLoginIframe\n    }\n\n    if (initOptions.checkLoginIframeInterval) {\n      this.#loginIframe.interval = initOptions.checkLoginIframeInterval\n    }\n\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true\n    }\n\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode\n      } else {\n        throw new Error('Invalid value for responseMode')\n      }\n    }\n\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code'\n          break\n        case 'implicit':\n          this.responseType = 'id_token token'\n          break\n        case 'hybrid':\n          this.responseType = 'code id_token token'\n          break\n        default:\n          throw new Error('Invalid value for flow')\n      }\n      this.flow = initOptions.flow\n    }\n\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew\n    }\n\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri\n    }\n\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri\n    }\n\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback\n    }\n\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`)\n      }\n\n      this.pkceMethod = initOptions.pkceMethod\n    }\n\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging\n    }\n\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST'\n    }\n\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope\n    }\n\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout\n    }\n\n    await this.#loadConfig()\n    await this.#check3pCookiesSupported()\n    await this.#processInit(initOptions)\n\n    this.onReady?.(this.authenticated)\n\n    return this.authenticated\n  }\n\n  /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */\n  #loadAdapter (type) {\n    if (type === 'default') {\n      return this.#loadDefaultAdapter()\n    }\n\n    if (type === 'cordova') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaAdapter()\n    }\n\n    if (type === 'cordova-native') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaNativeAdapter()\n    }\n\n    throw new Error('invalid adapter type: ' + type)\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadDefaultAdapter () {\n    /** @type {KeycloakAdapter['redirectUri']}{} */\n    const redirectUri = (options) => {\n      return options?.redirectUri || this.redirectUri || globalThis.location.href\n    }\n\n    return {\n      login: async (options) => {\n        window.location.assign(await this.createLoginUrl(options))\n        return await new Promise(() => {})\n      },\n\n      logout: async (options) => {\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n\n        if (logoutMethod === 'GET') {\n          window.location.replace(this.createLogoutUrl(options))\n          return\n        }\n\n        // Create form to send POST request.\n        const form = document.createElement('form')\n\n        form.setAttribute('method', 'POST')\n        form.setAttribute('action', this.createLogoutUrl(options))\n        form.style.display = 'none'\n\n        // Add data to form as hidden input fields.\n        const data = {\n          id_token_hint: this.idToken,\n          client_id: this.clientId,\n          post_logout_redirect_uri: redirectUri(options)\n        }\n\n        for (const [name, value] of Object.entries(data)) {\n          const input = document.createElement('input')\n\n          input.setAttribute('type', 'hidden')\n          input.setAttribute('name', name)\n          input.setAttribute('value', /** @type {string} */ (value))\n\n          form.appendChild(input)\n        }\n\n        // Append form to page and submit it to perform logout and redirect.\n        document.body.appendChild(form)\n        form.submit()\n      },\n\n      register: async (options) => {\n        window.location.assign(await this.createRegisterUrl(options))\n        return await new Promise(() => {})\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.location.href = accountUrl\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return await new Promise(() => {})\n      },\n\n      redirectUri\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaAdapter () {\n    /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */\n    const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n      if (window.cordova && window.cordova.InAppBrowser) {\n        // Use inappbrowser for IOS and Android if available\n        return window.cordova.InAppBrowser.open(loginUrl, target, options)\n      } else {\n        return window.open(loginUrl, target, options)\n      }\n    }\n\n    const shallowCloneCordovaOptions = (userOptions) => {\n      if (userOptions && userOptions.cordovaOptions) {\n        return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n          options[optionName] = userOptions.cordovaOptions[optionName]\n          return options\n        }, {})\n      } else {\n        return {}\n      }\n    }\n\n    const formatCordovaOptions = (cordovaOptions) => {\n      return Object.keys(cordovaOptions).reduce((options, optionName) => {\n        options.push(optionName + '=' + cordovaOptions[optionName])\n        return options\n      }, []).join(',')\n    }\n\n    const createCordovaOptions = (userOptions) => {\n      const cordovaOptions = shallowCloneCordovaOptions(userOptions)\n      cordovaOptions.location = 'no'\n      if (userOptions && userOptions.prompt === 'none') {\n        cordovaOptions.hidden = 'yes'\n      }\n      return formatCordovaOptions(cordovaOptions)\n    }\n\n    const getCordovaRedirectUri = () => {\n      return this.redirectUri || 'http://localhost'\n    }\n\n    return {\n      login: async (options) => {\n        const cordovaOptions = createCordovaOptions(options)\n        const loginUrl = await this.createLoginUrl(options)\n        const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions)\n        let completed = false\n        let closed = false\n\n        function closeBrowser () {\n          closed = true\n          ref.close()\n        };\n\n        return await new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(callback)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n              closeBrowser()\n              completed = true\n            }\n          })\n\n          ref.addEventListener('loaderror', async (event) => {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                const callback = this.#parseCallback(event.url)\n                try {\n                  await this.#processCallback(callback)\n                  resolve()\n                } catch (error) {\n                  reject(error)\n                }\n                closeBrowser()\n                completed = true\n              } else {\n                reject(new Error('Unable to process login.'))\n                closeBrowser()\n              }\n            }\n          })\n\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              reject(new Error('User closed the login window.'))\n            }\n          })\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n        const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes')\n        let error = false\n\n        ref.addEventListener('loadstart', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          }\n        })\n\n        ref.addEventListener('loaderror', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          } else {\n            error = true\n            ref.close()\n          }\n        })\n\n        await new Promise((resolve, reject) => {\n          ref.addEventListener('exit', () => {\n            if (error) {\n              reject(new Error('User closed the login window.'))\n            } else {\n              this.clearToken()\n              resolve()\n            }\n          })\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl()\n        const cordovaOptions = createCordovaOptions(options)\n        const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions)\n\n        /** @type {Promise<void>} */\n        const promise = new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n              const oauth = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(oauth)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n            }\n          })\n        })\n\n        await promise\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no')\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n            }\n          })\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: () => {\n        return getCordovaRedirectUri()\n      }\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaNativeAdapter () {\n    /* global universalLinks */\n    return {\n      login: async (options) => {\n        const loginUrl = await this.createLoginUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(loginUrl)\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n\n        await new Promise((resolve) => {\n          universalLinks.subscribe('keycloak', () => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            this.clearToken()\n            resolve()\n          })\n\n          window.cordova.plugins.browsertab.openUrl(logoutUrl)\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(registerUrl)\n        })\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.cordova.plugins.browsertab.openUrl(accountUrl)\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: (options) => {\n        if (options && options.redirectUri) {\n          return options.redirectUri\n        } else if (this.redirectUri) {\n          return this.redirectUri\n        } else {\n          return 'http://localhost'\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #loadConfig () {\n    if (typeof this.#config === 'string') {\n      const jsonConfig = await fetchJsonConfig(this.#config)\n      this.authServerUrl = jsonConfig['auth-server-url']\n      this.realm = jsonConfig.realm\n      this.clientId = jsonConfig.resource\n      this.#setupEndpoints()\n    } else {\n      this.clientId = this.#config.clientId\n\n      if ('oidcProvider' in this.#config) {\n        await this.#loadOidcConfig(this.#config.oidcProvider)\n      } else {\n        this.authServerUrl = this.#config.url\n        this.realm = this.#config.realm\n        this.#setupEndpoints()\n      }\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  #setupEndpoints () {\n    this.endpoints = {\n      authorize: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/auth'\n      },\n      token: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/token'\n      },\n      logout: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/logout'\n      },\n      checkSessionIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html'\n      },\n      thirdPartyCookiesIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html'\n      },\n      register: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/registrations'\n      },\n      userinfo: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/userinfo'\n      }\n    }\n  }\n\n  /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */\n  async #loadOidcConfig (oidcProvider) {\n    if (typeof oidcProvider === 'string') {\n      const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`\n      const openIdConfig = await fetchOpenIdConfig(url)\n      this.#setupOidcEndpoints(openIdConfig)\n    } else {\n      this.#setupOidcEndpoints(oidcProvider)\n    }\n  }\n\n  /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */\n  #setupOidcEndpoints (config) {\n    this.endpoints = {\n      authorize () {\n        return config.authorization_endpoint\n      },\n      token () {\n        return config.token_endpoint\n      },\n      logout () {\n        if (!config.end_session_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.end_session_endpoint\n      },\n      checkSessionIframe () {\n        if (!config.check_session_iframe) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.check_session_iframe\n      },\n      register () {\n        throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode')\n      },\n      userinfo () {\n        if (!config.userinfo_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.userinfo_endpoint\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #check3pCookiesSupported () {\n    if ((!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri) || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-3p-check-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = (event) => {\n        if (iframe.contentWindow !== event.source) {\n          return\n        }\n\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return\n        } else if (event.data === 'unsupported') {\n          this.#logWarn(\n            '[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' +\n                        ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' +\n                        ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' +\n                        'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers'\n          )\n\n          this.#loginIframe.enable = false\n          if (this.silentCheckSsoFallback) {\n            this.silentCheckSsoRedirectUri = undefined\n          }\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n        resolve()\n      }\n\n      window.addEventListener('message', messageCallback, false)\n    })\n\n    return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.')\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */\n  async #processInit (initOptions) {\n    const callback = this.#parseCallback(window.location.href)\n\n    if (callback?.redirectUri) {\n      window.history.replaceState(window.history.state, '', callback.redirectUri)\n    }\n\n    if (callback && callback.valid) {\n      await this.#setupCheckLoginIframe()\n      await this.#processCallback(callback)\n      return\n    }\n\n    /** @param {boolean} prompt */\n    const doLogin = async (prompt) => {\n      /** @type {KeycloakLoginOptions} */\n      const options = {}\n\n      if (!prompt) {\n        options.prompt = 'none'\n      }\n\n      if (initOptions.locale) {\n        options.locale = initOptions.locale\n      }\n\n      await this.login(options)\n    }\n\n    const onLoad = async () => {\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (this.#loginIframe.enable) {\n            await this.#setupCheckLoginIframe()\n            const unchanged = await this.#checkLoginIframe()\n\n            if (!unchanged) {\n              this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n            }\n          } else {\n            this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n          }\n          break\n        case 'login-required':\n          await doLogin(true)\n          break\n        default:\n          throw new Error('Invalid value for onLoad')\n      }\n    }\n\n    if (initOptions.token && initOptions.refreshToken) {\n      this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken)\n\n      if (this.#loginIframe.enable) {\n        await this.#setupCheckLoginIframe()\n        const unchanged = await this.#checkLoginIframe()\n\n        if (unchanged) {\n          this.onAuthSuccess?.()\n          this.#scheduleCheckIframe()\n        }\n      } else {\n        try {\n          await this.updateToken(-1)\n          this.onAuthSuccess?.()\n        } catch (error) {\n          this.onAuthError?.()\n          if (initOptions.onLoad) {\n            await onLoad()\n          } else {\n            throw error\n          }\n        }\n      }\n    } else if (initOptions.onLoad) {\n      await onLoad()\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #setupCheckLoginIframe () {\n    if (!this.#loginIframe.enable || this.#loginIframe.iframe) {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    this.#loginIframe.iframe = iframe\n    iframe.setAttribute('src', this.endpoints.checkSessionIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-session-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = (event) => {\n      if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) {\n        return\n      }\n\n      if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n        return\n      }\n\n      if (event.data !== 'unchanged') {\n        this.clearToken()\n      }\n\n      const callbacks = this.#loginIframe.callbackList\n      this.#loginIframe.callbackList = []\n\n      for (const callback of callbacks.reverse()) {\n        if (event.data === 'error') {\n          callback(new Error('Error while checking login iframe'))\n        } else {\n          callback(null, event.data === 'unchanged')\n        }\n      }\n    }\n\n    window.addEventListener('message', messageCallback, false)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      iframe.addEventListener('load', () => {\n        const authUrl = this.endpoints.authorize()\n        if (authUrl.startsWith('/')) {\n          this.#loginIframe.iframeOrigin = globalThis.location.origin\n        } else {\n          this.#loginIframe.iframeOrigin = new URL(authUrl).origin\n        }\n        resolve()\n      })\n    })\n\n    await promise\n  }\n\n  /**\n   * @returns {Promise<boolean | undefined>}\n   */\n  async #checkLoginIframe () {\n    if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) {\n      return\n    }\n\n    const message = `${this.clientId} ${(this.sessionId ? this.sessionId : '')}`\n    const origin = this.#loginIframe.iframeOrigin\n\n    /** @type {Promise<boolean>} */\n    const promise = new Promise((resolve, reject) => {\n      /** @type {(error: Error | null, value?: boolean) => void} */\n      const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */ (result))\n\n      this.#loginIframe.callbackList.push(callback)\n\n      if (this.#loginIframe.callbackList.length === 1) {\n        this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin)\n      }\n    })\n\n    return await promise\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #checkSsoSilently () {\n    const iframe = document.createElement('iframe')\n    const src = await this.createLoginUrl({ prompt: 'none', redirectUri: this.silentCheckSsoRedirectUri })\n    iframe.setAttribute('src', src)\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-silent-check-sso')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    return await new Promise((resolve, reject) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = async (event) => {\n        if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n          return\n        }\n\n        const oauth = this.#parseCallback(event.data)\n\n        try {\n          await this.#processCallback(oauth)\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n      }\n\n      window.addEventListener('message', messageCallback)\n    })\n  };\n\n  /**\n   * @param {string} url\n   */\n  #parseCallback (url) {\n    const oauth = this.#parseCallbackUrl(url)\n    if (!oauth) {\n      return\n    }\n\n    const oauthState = this.#callbackStorage.get(oauth.state)\n\n    if (oauthState) {\n      oauth.valid = true\n      oauth.redirectUri = oauthState.redirectUri\n      oauth.storedNonce = oauthState.nonce\n      oauth.prompt = oauthState.prompt\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier\n      oauth.loginOptions = oauthState.loginOptions\n    }\n\n    return oauth\n  }\n\n  /**\n   * @param {string} urlString\n   */\n  #parseCallbackUrl (urlString) {\n    let supportedParams = []\n    switch (this.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n    }\n\n    supportedParams.push('error')\n    supportedParams.push('error_description')\n    supportedParams.push('error_uri')\n\n    const url = new URL(urlString)\n    let redirectUri = ''\n    let parsed\n\n    if (this.responseMode === 'query' && url.searchParams.size > 0) {\n      parsed = this.#parseCallbackParams(url.search, supportedParams)\n      url.search = parsed.paramsString\n      redirectUri = url.toString()\n    } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n      parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams)\n      url.hash = ''\n      redirectUri = url.toString()\n    }\n\n    if (parsed?.oauthParams) {\n      if (this.flow === 'standard' || this.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      } else if (this.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */\n\n  /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */\n  #parseCallbackParams (paramsString, supportedParams) {\n    const params = new URLSearchParams(paramsString)\n    /** @type {Record<string, string>} */\n    const oauthParams = {}\n\n    for (const [key, value] of Array.from(params.entries())) {\n      if (supportedParams.includes(key)) {\n        oauthParams[key] = value\n        params.delete(key)\n      }\n    }\n\n    return {\n      paramsString: params.toString(),\n      oauthParams\n    }\n  }\n\n  async #processCallback (oauth) {\n    const { code, error, prompt } = oauth\n    let timeLocal = new Date().getTime()\n\n    /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */\n    const authSuccess = (accessToken, refreshToken, idToken) => {\n      timeLocal = (timeLocal + new Date().getTime()) / 2\n\n      this.#setToken(accessToken, refreshToken, idToken, timeLocal)\n\n      if (this.#useNonce && (this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce)) {\n        this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token')\n        this.clearToken()\n        throw new Error('Invalid nonce.')\n      }\n    }\n\n    if (oauth.kc_action_status) {\n      this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action)\n    }\n\n    if (error) {\n      if (prompt !== 'none') {\n        if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n          await this.login(oauth.loginOptions)\n        } else {\n          const errorData = { error, error_description: oauth.error_description }\n          this.onAuthError?.(errorData)\n          throw errorData\n        }\n      }\n      return\n    } else if ((this.flow !== 'standard') && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, undefined, oauth.id_token)\n      this.onAuthSuccess?.()\n    }\n\n    if ((this.flow !== 'implicit') && code) {\n      try {\n        const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */ (this.clientId), oauth.redirectUri, oauth.pkceCodeVerifier)\n        authSuccess(response.access_token, response.refresh_token, response.id_token)\n\n        if (this.flow === 'standard') {\n          this.onAuthSuccess?.()\n        }\n\n        this.#scheduleCheckIframe()\n      } catch (error) {\n        this.onAuthError?.()\n        throw error\n      }\n    }\n  }\n\n  async #scheduleCheckIframe () {\n    if (this.#loginIframe.enable && this.token) {\n      await waitForTimeout(this.#loginIframe.interval * 1000)\n      const unchanged = await this.#checkLoginIframe()\n\n      if (unchanged) {\n        await this.#scheduleCheckIframe()\n      }\n    }\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login (options) {\n    return this.#adapter.login(options)\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  async createLoginUrl (options) {\n    const state = createUUID()\n    const nonce = createUUID()\n    const redirectUri = this.#adapter.redirectUri(options)\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    }\n\n    if (options?.prompt) {\n      callbackState.prompt = options.prompt\n    }\n\n    const url = options?.action === 'register'\n      ? this.endpoints.register()\n      : this.endpoints.authorize()\n\n    let scope = options?.scope || this.scope\n    const scopeValues = scope ? scope.split(' ') : []\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid')\n    }\n\n    scope = scopeValues.join(' ')\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      // The endpoint URI MUST NOT include a fragment component.\n      // https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\n      ['redirect_uri', stripHash(redirectUri)],\n      ['state', state],\n      ['response_mode', this.responseMode],\n      ['response_type', this.responseType],\n      ['scope', scope]\n    ])\n\n    if (this.#useNonce) {\n      params.append('nonce', nonce)\n    }\n\n    if (options?.prompt) {\n      params.append('prompt', options.prompt)\n    }\n\n    if (typeof options?.maxAge === 'number') {\n      params.append('max_age', options.maxAge.toString())\n    }\n\n    if (options?.loginHint) {\n      params.append('login_hint', options.loginHint)\n    }\n\n    if (options?.idpHint) {\n      params.append('kc_idp_hint', options.idpHint)\n    }\n\n    if (options?.action && options.action !== 'register') {\n      params.append('kc_action', options.action)\n    }\n\n    if (options?.locale) {\n      params.append('ui_locales', options.locale)\n    }\n\n    if (options?.acr) {\n      params.append('claims', buildClaimsParameter(options.acr))\n    }\n\n    if (options?.acrValues) {\n      params.append('acr_values', options.acrValues)\n    }\n\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96)\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier)\n\n        callbackState.pkceCodeVerifier = codeVerifier\n\n        params.append('code_challenge', pkceChallenge)\n        params.append('code_challenge_method', this.pkceMethod)\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', { cause: error })\n      }\n    }\n\n    this.#callbackStorage.add(callbackState)\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout (options) {\n    return this.#adapter.logout(options)\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl (options) {\n    const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n    const url = this.endpoints.logout()\n\n    if (logoutMethod === 'POST') {\n      return url\n    }\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      ['post_logout_redirect_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken)\n    }\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register (options) {\n    return this.#adapter.register(options)\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl (options) {\n    return this.createLoginUrl({ ...options, action: 'register' })\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl (options) {\n    const url = this.#getRealmUrl()\n\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const params = new URLSearchParams([\n      ['referrer', /** @type {string} */ (this.clientId)],\n      ['referrer_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    return `${url}/account?${params.toString()}`\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement () {\n    return this.#adapter.accountManagement()\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole (role) {\n    const access = this.realmAccess\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole (role, resource) {\n    if (!this.resourceAccess) {\n      return false\n    }\n\n    const access = this.resourceAccess[resource || /** @type {string} */ (this.clientId)]\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  async loadUserProfile () {\n    const realmUrl = this.#getRealmUrl()\n\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const url = `${realmUrl}/account`\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.profile = profile)\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  async loadUserInfo () {\n    const url = this.endpoints.userinfo()\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.userInfo = userInfo)\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired (minValidity) {\n    if (!this.tokenParsed || (!this.refreshToken && this.flow !== 'implicit')) {\n      throw new Error('Not authenticated')\n    }\n\n    if (this.timeSkew == null) {\n      this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set')\n      return true\n    }\n\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false\n    }\n\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity')\n      }\n      expiresIn -= minValidity\n    }\n    return expiresIn < 0\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  async updateToken (minValidity) {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.')\n    }\n\n    minValidity = minValidity || 5\n\n    if (this.#loginIframe.enable) {\n      await this.#checkLoginIframe()\n    }\n\n    let refreshToken = false\n\n    if (minValidity === -1) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh')\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: token expired')\n    }\n\n    if (!refreshToken) {\n      return false\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const { promise, resolve, reject } = Promise.withResolvers()\n\n    this.#refreshQueue.push({ resolve, reject })\n\n    if (this.#refreshQueue.length === 1) {\n      const url = this.endpoints.token()\n      let timeLocal = new Date().getTime()\n\n      try {\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */ (this.clientId))\n        this.#logInfo('[KEYCLOAK] Token refreshed')\n\n        timeLocal = (timeLocal + new Date().getTime()) / 2\n\n        this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal)\n\n        this.onAuthRefreshSuccess?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.resolve(true)\n        }\n      } catch (error) {\n        this.#logWarn('[KEYCLOAK] Failed to refresh token')\n\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken()\n        }\n\n        this.onAuthRefreshError?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.reject(error)\n        }\n      }\n    }\n\n    return await promise\n  }\n\n  clearToken () {\n    if (this.token) {\n      this.#setToken()\n      this.onAuthLogout?.()\n      if (this.loginRequired) {\n        this.login()\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n  #setToken (token, refreshToken, idToken, timeLocal) {\n    if (this.tokenTimeoutHandle) {\n      clearTimeout(this.tokenTimeoutHandle)\n      this.tokenTimeoutHandle = undefined\n    }\n\n    if (refreshToken) {\n      this.refreshToken = refreshToken\n      this.refreshTokenParsed = decodeToken(refreshToken)\n    } else {\n      delete this.refreshToken\n      delete this.refreshTokenParsed\n    }\n\n    if (idToken) {\n      this.idToken = idToken\n      this.idTokenParsed = decodeToken(idToken)\n    } else {\n      delete this.idToken\n      delete this.idTokenParsed\n    }\n\n    if (token) {\n      this.token = token\n      this.tokenParsed = decodeToken(token)\n      this.sessionId = this.tokenParsed.sid\n      this.authenticated = true\n      this.subject = this.tokenParsed.sub\n      this.realmAccess = this.tokenParsed.realm_access\n      this.resourceAccess = this.tokenParsed.resource_access\n\n      if (timeLocal) {\n        this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat\n      }\n\n      if (this.timeSkew !== null) {\n        this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds')\n\n        if (this.onTokenExpired) {\n          const expiresIn = (this.tokenParsed.exp - (new Date().getTime() / 1000) + this.timeSkew) * 1000\n          this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s')\n          if (expiresIn <= 0) {\n            this.onTokenExpired()\n          } else {\n            this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn)\n          }\n        }\n      }\n    } else {\n      delete this.token\n      delete this.tokenParsed\n      delete this.subject\n      delete this.realmAccess\n      delete this.resourceAccess\n\n      this.authenticated = false\n    }\n  }\n\n  /**\n   * @returns {string=}\n   */\n  #getRealmUrl () {\n    if (typeof this.authServerUrl === 'undefined') {\n      return\n    }\n\n    return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */ (this.realm))}`\n  }\n\n  /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */\n  #createLogger (fn) {\n    return (message) => {\n      if (this.enableLogging) {\n        fn.call(console, message)\n      }\n    }\n  }\n}\n\n/**\n * @returns {string}\n */\nfunction createUUID () {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.randomUUID()\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter (requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  })\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier (len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge (pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`)\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier))\n  const encodedHash = bytesToBase64(hashBytes)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n\n  return encodedHash\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString (len, alphabet) {\n  const randomData = generateRandomData(len)\n  const chars = new Array(len)\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length)\n  }\n  return String.fromCharCode.apply(null, chars)\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData (len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.getRandomValues(new Uint8Array(len))\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise (promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'))\n    }, timeout)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle)\n  })\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage () {\n  try {\n    return new LocalStorage()\n  } catch (err) {\n    return new CookieStorage()\n  }\n}\n\nconst STORAGE_KEY_PREFIX = 'kc-callback-'\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nclass LocalStorage {\n  constructor () {\n    globalThis.localStorage.setItem('kc-test', 'test')\n    globalThis.localStorage.removeItem('kc-test')\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state\n    const value = globalThis.localStorage.getItem(key)\n\n    if (value) {\n      globalThis.localStorage.removeItem(key)\n      return JSON.parse(value)\n    }\n\n    return null\n  };\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state.state\n    const value = JSON.stringify({\n      ...state,\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + (60 * 60 * 1000)\n    })\n\n    try {\n      globalThis.localStorage.setItem(key, value)\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      this.#clearAllValues()\n      globalThis.localStorage.setItem(key, value)\n    }\n  };\n\n  /**\n   * Clears all values from local storage that are no longer valid.\n   */\n  #clearInvalidValues () {\n    const currentTime = Date.now()\n\n    for (const [key, value] of this.#getStoredEntries()) {\n      // Attempt to parse the expiry time from the value.\n      const expiry = this.#parseExpiry(value)\n\n      // Discard the value if it is malformed or expired.\n      if (expiry === null || expiry < currentTime) {\n        globalThis.localStorage.removeItem(key)\n      }\n    }\n  }\n\n  /**\n   * Clears all known values from local storage.\n   */\n  #clearAllValues () {\n    for (const [key] of this.#getStoredEntries()) {\n      globalThis.localStorage.removeItem(key)\n    }\n  }\n\n  /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */\n  #getStoredEntries () {\n    return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX))\n  }\n\n  /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */\n  #parseExpiry (value) {\n    let parsedValue\n\n    // Attempt to parse the value as JSON.\n    try {\n      parsedValue = JSON.parse(value)\n    } catch (error) {\n      return null\n    }\n\n    // Attempt to extract the 'expires' property.\n    if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n      return parsedValue.expires\n    }\n\n    return null\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nclass CookieStorage {\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    const value = this.#getCookie(STORAGE_KEY_PREFIX + state)\n    this.#setCookie(STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100))\n    if (value) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60))\n  }\n\n  /**\n   * @param {string} key\n   * @returns\n   */\n  #getCookie (key) {\n    const name = key + '='\n    const ca = document.cookie.split(';')\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i]\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1)\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length)\n      }\n    }\n    return ''\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */\n  #setCookie (key, value, expirationDate) {\n    const cookie = key + '=' + value + '; ' +\n            'expires=' + expirationDate.toUTCString() + '; '\n    document.cookie = cookie\n  }\n\n  /**\n   * @param {number} minutes\n   * @returns {Date}\n   */\n  #cookieExpiration (minutes) {\n    const exp = new Date()\n    exp.setTime(exp.getTime() + (minutes * 60 * 1000))\n    return exp\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64 (bytes) {\n  const binString = String.fromCodePoint(...bytes)\n  return btoa(binString)\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest (message) {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(message)\n\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return await crypto.subtle.digest('SHA-256', data)\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken (token) {\n  const [, payload] = token.split('.')\n\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.')\n  }\n\n  let decoded\n\n  try {\n    decoded = base64UrlDecode(payload)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', { cause: error })\n  }\n\n  try {\n    return JSON.parse(decoded)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', { cause: error })\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode (input) {\n  let output = input\n    .replaceAll('-', '+')\n    .replaceAll('_', '/')\n\n  switch (output.length % 4) {\n    case 0:\n      break\n    case 2:\n      output += '=='\n      break\n    case 3:\n      output += '='\n      break\n    default:\n      throw new Error('Input is not of the correct length.')\n  }\n\n  try {\n    return b64DecodeUnicode(output)\n  } catch (error) {\n    return atob(output)\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode (input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase()\n\n    if (code.length < 2) {\n      code = '0' + code\n    }\n\n    return '%' + code\n  }))\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject (input) {\n  return typeof input === 'object' && input !== null\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken (url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([\n    ['code', code],\n    ['grant_type', 'authorization_code'],\n    ['client_id', clientId],\n    ['redirect_uri', stripHash(redirectUri)]\n  ])\n\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier)\n  }\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken (url, refreshToken, clientId) {\n  const body = new URLSearchParams([\n    ['grant_type', 'refresh_token'],\n    ['refresh_token', refreshToken],\n    ['client_id', clientId]\n  ])\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON (url, init = {}) {\n  const headers = new Headers(init.headers)\n  headers.set('Accept', CONTENT_TYPE_JSON)\n\n  const response = await fetchWithErrorHandling(url, {\n    ...init,\n    headers\n  })\n\n  return await response.json()\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling (url, init) {\n  const response = await fetch(url, init)\n\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', { response })\n  }\n\n  return response\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader (token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.')\n  }\n\n  return ['Authorization', `bearer ${token}`]\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash (url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash (url) {\n  const parsedUrl = new URL(url)\n  parsedUrl.hash = ''\n  return parsedUrl.toString()\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nclass NetworkError extends Error {\n  /** @type {Response} */\n  response\n\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor (message, options) {\n    super(message, options)\n    this.response = options.response\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2tleWNsb2FrLWpzL2xpYi9rZXljbG9hay5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQSxZQUFZLDJWQUEyVjtBQUN2VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QixjQUFjLGNBQWM7QUFDNUIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxvREFBb0Q7QUFDbEUsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsU0FBUztBQUN2Qjs7QUFFZTtBQUNmLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNB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O0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE1BQU07QUFDM0M7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCLGFBQWEsOENBQThDO0FBQzNEOztBQUVPO0FBQ1AsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWVudG8tbW9yaS12ZW5kb3ItcG9ydGFsLy4uLy4uL25vZGVfbW9kdWxlcy9rZXljbG9hay1qcy9saWIva2V5Y2xvYWsuanM/NmQ5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcbi8qKlxuICogQGltcG9ydCB7QWNyLCBLZXljbG9ha0FjY291bnRPcHRpb25zLCBLZXljbG9ha0FkYXB0ZXIsIEtleWNsb2FrQ29uZmlnLCBLZXljbG9ha0Vycm9yLCBLZXljbG9ha0Zsb3csIEtleWNsb2FrSW5pdE9wdGlvbnMsIEtleWNsb2FrTG9naW5PcHRpb25zLCBLZXljbG9ha0xvZ291dE9wdGlvbnMsIEtleWNsb2FrUGtjZU1ldGhvZCwgS2V5Y2xvYWtQcm9maWxlLCBLZXljbG9ha1JlZ2lzdGVyT3B0aW9ucywgS2V5Y2xvYWtSZXNvdXJjZUFjY2VzcywgS2V5Y2xvYWtSZXNwb25zZU1vZGUsIEtleWNsb2FrUmVzcG9uc2VUeXBlLCBLZXljbG9ha1JvbGVzLCBLZXljbG9ha1Rva2VuUGFyc2VkLCBPcGVuSWRQcm92aWRlck1ldGFkYXRhfSBmcm9tIFwiLi9rZXljbG9hay50c1wiXG4gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlc1xuICogYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyBhcyBpbmRpY2F0ZWQgYnkgdGhlIEBhdXRob3IgdGFncy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBDT05URU5UX1RZUEVfSlNPTiA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVuZHBvaW50c1xuICogQHByb3BlcnR5IHsoKSA9PiBzdHJpbmd9IGF1dGhvcml6ZVxuICogQHByb3BlcnR5IHsoKSA9PiBzdHJpbmd9IHRva2VuXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gbG9nb3V0XG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gY2hlY2tTZXNzaW9uSWZyYW1lXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZz19IHRoaXJkUGFydHlDb29raWVzSWZyYW1lXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gcmVnaXN0ZXJcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nfSB1c2VyaW5mb1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTG9naW5JZnJhbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5hYmxlXG4gKiBAcHJvcGVydHkgeygoZXJyb3I6IEVycm9yIHwgbnVsbCwgdmFsdWU/OiBib29sZWFuKSA9PiB2b2lkKVtdfSBjYWxsYmFja0xpc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlcnZhbFxuICogQHByb3BlcnR5IHtIVE1MSUZyYW1lRWxlbWVudD19IGlmcmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBpZnJhbWVPcmlnaW5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXljbG9hayB7XG4gIC8qKiBAdHlwZSB7UGljazxQcm9taXNlV2l0aFJlc29sdmVyczxib29sZWFuPiwgJ3Jlc29sdmUnIHwgJ3JlamVjdCc+W119ICovXG4gICNyZWZyZXNoUXVldWUgPSBbXVxuICAvKiogQHR5cGUge0tleWNsb2FrQWRhcHRlcn0gKi9cbiAgI2FkYXB0ZXJcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAjdXNlTm9uY2UgPSB0cnVlXG4gIC8qKiBAdHlwZSB7Q2FsbGJhY2tTdG9yYWdlfSAqL1xuICAjY2FsbGJhY2tTdG9yYWdlXG4gICNsb2dJbmZvID0gdGhpcy4jY3JlYXRlTG9nZ2VyKGNvbnNvbGUuaW5mbylcbiAgI2xvZ1dhcm4gPSB0aGlzLiNjcmVhdGVMb2dnZXIoY29uc29sZS53YXJuKVxuICAvKiogQHR5cGUge0xvZ2luSWZyYW1lfSAqL1xuICAjbG9naW5JZnJhbWUgPSB7XG4gICAgZW5hYmxlOiB0cnVlLFxuICAgIGNhbGxiYWNrTGlzdDogW10sXG4gICAgaW50ZXJ2YWw6IDVcbiAgfVxuXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtDb25maWd9IGNvbmZpZyAqL1xuICAjY29uZmlnXG4gIGRpZEluaXRpYWxpemUgPSBmYWxzZVxuICBhdXRoZW50aWNhdGVkID0gZmFsc2VcbiAgbG9naW5SZXF1aXJlZCA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtSZXNwb25zZU1vZGV9ICovXG4gIHJlc3BvbnNlTW9kZSA9ICdmcmFnbWVudCdcbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Jlc3BvbnNlVHlwZX0gKi9cbiAgcmVzcG9uc2VUeXBlID0gJ2NvZGUnXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtGbG93fSAqL1xuICBmbG93ID0gJ3N0YW5kYXJkJ1xuICAvKiogQHR5cGUge251bWJlcj99ICovXG4gIHRpbWVTa2V3ID0gbnVsbFxuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHJlZGlyZWN0VXJpXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaVxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIHNpbGVudENoZWNrU3NvRmFsbGJhY2sgPSB0cnVlXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtQa2NlTWV0aG9kfSAqL1xuICBwa2NlTWV0aG9kID0gJ1MyNTYnXG4gIGVuYWJsZUxvZ2dpbmcgPSBmYWxzZVxuICAvKiogQHR5cGUgeydHRVQnIHwgJ1BPU1QnfSAqL1xuICBsb2dvdXRNZXRob2QgPSAnR0VUJ1xuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHNjb3BlXG4gIG1lc3NhZ2VSZWNlaXZlVGltZW91dCA9IDEwMDAwXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgaWRUb2tlblxuICAvKiogQHR5cGUge0tleWNsb2FrVG9rZW5QYXJzZWQ9fSAqL1xuICBpZFRva2VuUGFyc2VkXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgdG9rZW5cbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Rva2VuUGFyc2VkPX0gKi9cbiAgdG9rZW5QYXJzZWRcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICByZWZyZXNoVG9rZW5cbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Rva2VuUGFyc2VkPX0gKi9cbiAgcmVmcmVzaFRva2VuUGFyc2VkXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgY2xpZW50SWRcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBzZXNzaW9uSWRcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBzdWJqZWN0XG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgYXV0aFNlcnZlclVybFxuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHJlYWxtXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtSb2xlcz19ICovXG4gIHJlYWxtQWNjZXNzXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtSZXNvdXJjZUFjY2Vzcz19ICovXG4gIHJlc291cmNlQWNjZXNzXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtQcm9maWxlPX0gKi9cbiAgcHJvZmlsZVxuICAvKiogQHR5cGUge3t9PX0gKi9cbiAgdXNlckluZm9cbiAgLyoqIEB0eXBlIHtFbmRwb2ludHN9ICovXG4gIGVuZHBvaW50c1xuICAvKiogQHR5cGUge251bWJlcj19ICovXG4gIHRva2VuVGltZW91dEhhbmRsZVxuICAvKiogQHR5cGUgeygpID0+IHZvaWQ9fSAqL1xuICBvbkF1dGhTdWNjZXNzXG4gIC8qKiBAdHlwZSB7KGVycm9yRGF0YT86IEtleWNsb2FrRXJyb3IpID0+IHZvaWQ9fSAqL1xuICBvbkF1dGhFcnJvclxuICAvKiogQHR5cGUgeygpID0+IHZvaWQ9fSAqL1xuICBvbkF1dGhSZWZyZXNoU3VjY2Vzc1xuICAvKiogQHR5cGUgeygpID0+IHZvaWQ9fSAqL1xuICBvbkF1dGhSZWZyZXNoRXJyb3JcbiAgLyoqIEB0eXBlIHsoKSA9PiB2b2lkPX0gKi9cbiAgb25Ub2tlbkV4cGlyZWRcbiAgLyoqIEB0eXBlIHsoKSA9PiB2b2lkPX0gKi9cbiAgb25BdXRoTG9nb3V0XG4gIC8qKiBAdHlwZSB7KGF1dGhlbnRpY2F0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ9fSAqL1xuICBvblJlYWR5XG4gIC8qKiBAdHlwZSB7KHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2NhbmNlbGxlZCcgfCAnZXJyb3InLCBhY3Rpb246IHN0cmluZykgPT4gdm9pZD19ICovXG4gIG9uQWN0aW9uVXBkYXRlXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtDb25maWd9IGNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJyAmJiAhaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdLZXljbG9haycgY29uc3RydWN0b3IgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3QsIG9yIGEgVVJMIHRvIGEgSlNPTiBjb25maWd1cmF0aW9uIGZpbGUuXCIpXG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIGNvbnN0IHJlcXVpcmVkUHJvcGVydGllcyA9ICdvaWRjUHJvdmlkZXInIGluIGNvbmZpZ1xuICAgICAgICA/IFsnY2xpZW50SWQnXVxuICAgICAgICA6IFsndXJsJywgJ3JlYWxtJywgJ2NsaWVudElkJ11cblxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiByZXF1aXJlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gY29uZmlnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIG1pc3NpbmcgdGhlIHJlcXVpcmVkICcke3Byb3BlcnR5fScgcHJvcGVydHkuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2xvYmFsVGhpcy5pc1NlY3VyZUNvbnRleHQpIHtcbiAgICAgIHRoaXMuI2xvZ1dhcm4oXG4gICAgICAgIFwiW0tFWUNMT0FLXSBLZXljbG9hayBKUyBtdXN0IGJlIHVzZWQgaW4gYSAnc2VjdXJlIGNvbnRleHQnIHRvIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGl0IHJlbGllcyBvbiBicm93c2VyIEFQSXMgdGhhdCBhcmUgb3RoZXJ3aXNlIG5vdCBhdmFpbGFibGUuXFxuXCIgK1xuICAgICAgICAgICAgICAgICdDb250aW51aW5nIHRvIHJ1biB5b3VyIGFwcGxpY2F0aW9uIGluc2VjdXJlbHkgd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgYW5kIGJyZWFrYWdlLlxcblxcbicgK1xuICAgICAgICAgICAgICAgICdGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NlY3VyaXR5L1NlY3VyZV9Db250ZXh0cydcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLiNjb25maWcgPSBjb25maWdcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrSW5pdE9wdGlvbnN9IGluaXRPcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgaW5pdCAoaW5pdE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLmRpZEluaXRpYWxpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgJ0tleWNsb2FrJyBpbnN0YW5jZSBjYW4gb25seSBiZSBpbml0aWFsaXplZCBvbmNlLlwiKVxuICAgIH1cblxuICAgIHRoaXMuZGlkSW5pdGlhbGl6ZSA9IHRydWVcbiAgICB0aGlzLiNjYWxsYmFja1N0b3JhZ2UgPSBjcmVhdGVDYWxsYmFja1N0b3JhZ2UoKVxuXG4gICAgY29uc3QgYWRhcHRlcnMgPSBbJ2RlZmF1bHQnLCAnY29yZG92YScsICdjb3Jkb3ZhLW5hdGl2ZSddXG5cbiAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLmFkYXB0ZXIgPT09ICdzdHJpbmcnICYmIGFkYXB0ZXJzLmluY2x1ZGVzKGluaXRPcHRpb25zLmFkYXB0ZXIpKSB7XG4gICAgICB0aGlzLiNhZGFwdGVyID0gdGhpcy4jbG9hZEFkYXB0ZXIoaW5pdE9wdGlvbnMuYWRhcHRlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5hZGFwdGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy4jYWRhcHRlciA9IGluaXRPcHRpb25zLmFkYXB0ZXJcbiAgICB9IGVsc2UgaWYgKCdDb3Jkb3ZhJyBpbiB3aW5kb3cgfHwgJ2NvcmRvdmEnIGluIHdpbmRvdykge1xuICAgICAgdGhpcy4jYWRhcHRlciA9IHRoaXMuI2xvYWRBZGFwdGVyKCdjb3Jkb3ZhJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jYWRhcHRlciA9IHRoaXMuI2xvYWRBZGFwdGVyKCdkZWZhdWx0JylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLnVzZU5vbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy4jdXNlTm9uY2UgPSBpbml0T3B0aW9ucy51c2VOb25jZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuY2hlY2tMb2dpbklmcmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSA9IGluaXRPcHRpb25zLmNoZWNrTG9naW5JZnJhbWVcbiAgICB9XG5cbiAgICBpZiAoaW5pdE9wdGlvbnMuY2hlY2tMb2dpbklmcmFtZUludGVydmFsKSB7XG4gICAgICB0aGlzLiNsb2dpbklmcmFtZS5pbnRlcnZhbCA9IGluaXRPcHRpb25zLmNoZWNrTG9naW5JZnJhbWVJbnRlcnZhbFxuICAgIH1cblxuICAgIGlmIChpbml0T3B0aW9ucy5vbkxvYWQgPT09ICdsb2dpbi1yZXF1aXJlZCcpIHtcbiAgICAgIHRoaXMubG9naW5SZXF1aXJlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlKSB7XG4gICAgICBpZiAoaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlID09PSAncXVlcnknIHx8IGluaXRPcHRpb25zLnJlc3BvbnNlTW9kZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICB0aGlzLnJlc3BvbnNlTW9kZSA9IGluaXRPcHRpb25zLnJlc3BvbnNlTW9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciByZXNwb25zZU1vZGUnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0T3B0aW9ucy5mbG93KSB7XG4gICAgICBzd2l0Y2ggKGluaXRPcHRpb25zLmZsb3cpIHtcbiAgICAgICAgY2FzZSAnc3RhbmRhcmQnOlxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2NvZGUnXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gJ2lkX3Rva2VuIHRva2VuJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2h5YnJpZCc6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnY29kZSBpZF90b2tlbiB0b2tlbidcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgZmxvdycpXG4gICAgICB9XG4gICAgICB0aGlzLmZsb3cgPSBpbml0T3B0aW9ucy5mbG93XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy50aW1lU2tldyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudGltZVNrZXcgPSBpbml0T3B0aW9ucy50aW1lU2tld1xuICAgIH1cblxuICAgIGlmIChpbml0T3B0aW9ucy5yZWRpcmVjdFVyaSkge1xuICAgICAgdGhpcy5yZWRpcmVjdFVyaSA9IGluaXRPcHRpb25zLnJlZGlyZWN0VXJpXG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmkpIHtcbiAgICAgIHRoaXMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSA9IGluaXRPcHRpb25zLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLnNpbGVudENoZWNrU3NvRmFsbGJhY2sgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5zaWxlbnRDaGVja1Nzb0ZhbGxiYWNrID0gaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29GYWxsYmFja1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMucGtjZU1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChpbml0T3B0aW9ucy5wa2NlTWV0aG9kICE9PSAnUzI1NicgJiYgaW5pdE9wdGlvbnMucGtjZU1ldGhvZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgcGtjZU1ldGhvZCcsIGV4cGVjdGVkICdTMjU2JyBvciBmYWxzZSBidXQgZ290ICR7aW5pdE9wdGlvbnMucGtjZU1ldGhvZH0uYClcbiAgICAgIH1cblxuICAgICAgdGhpcy5wa2NlTWV0aG9kID0gaW5pdE9wdGlvbnMucGtjZU1ldGhvZFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuZW5hYmxlTG9nZ2luZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLmVuYWJsZUxvZ2dpbmcgPSBpbml0T3B0aW9ucy5lbmFibGVMb2dnaW5nXG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLmxvZ291dE1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICB0aGlzLmxvZ291dE1ldGhvZCA9ICdQT1NUJ1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNjb3BlID0gaW5pdE9wdGlvbnMuc2NvcGVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLm1lc3NhZ2VSZWNlaXZlVGltZW91dCA9PT0gJ251bWJlcicgJiYgaW5pdE9wdGlvbnMubWVzc2FnZVJlY2VpdmVUaW1lb3V0ID4gMCkge1xuICAgICAgdGhpcy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQgPSBpbml0T3B0aW9ucy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXRcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLiNsb2FkQ29uZmlnKClcbiAgICBhd2FpdCB0aGlzLiNjaGVjazNwQ29va2llc1N1cHBvcnRlZCgpXG4gICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0luaXQoaW5pdE9wdGlvbnMpXG5cbiAgICB0aGlzLm9uUmVhZHk/Lih0aGlzLmF1dGhlbnRpY2F0ZWQpXG5cbiAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdGVkXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtcImRlZmF1bHRcIiB8IFwiY29yZG92YVwiIHwgXCJjb3Jkb3ZhLW5hdGl2ZVwifSB0eXBlXG4gICAqIEByZXR1cm5zIHtLZXljbG9ha0FkYXB0ZXJ9XG4gICAqL1xuICAjbG9hZEFkYXB0ZXIgKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbG9hZERlZmF1bHRBZGFwdGVyKClcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvcmRvdmEnKSB7XG4gICAgICB0aGlzLiNsb2dpbklmcmFtZS5lbmFibGUgPSBmYWxzZVxuICAgICAgcmV0dXJuIHRoaXMuI2xvYWRDb3Jkb3ZhQWRhcHRlcigpXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdjb3Jkb3ZhLW5hdGl2ZScpIHtcbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpcy4jbG9hZENvcmRvdmFOYXRpdmVBZGFwdGVyKClcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRhcHRlciB0eXBlOiAnICsgdHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7S2V5Y2xvYWtBZGFwdGVyfVxuICAgKi9cbiAgI2xvYWREZWZhdWx0QWRhcHRlciAoKSB7XG4gICAgLyoqIEB0eXBlIHtLZXljbG9ha0FkYXB0ZXJbJ3JlZGlyZWN0VXJpJ119e30gKi9cbiAgICBjb25zdCByZWRpcmVjdFVyaSA9IChvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gb3B0aW9ucz8ucmVkaXJlY3RVcmkgfHwgdGhpcy5yZWRpcmVjdFVyaSB8fCBnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWZcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9naW46IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXdhaXQgdGhpcy5jcmVhdGVMb2dpblVybChvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfSxcblxuICAgICAgbG9nb3V0OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBsb2dvdXRNZXRob2QgPSBvcHRpb25zPy5sb2dvdXRNZXRob2QgPz8gdGhpcy5sb2dvdXRNZXRob2RcblxuICAgICAgICBpZiAobG9nb3V0TWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMuY3JlYXRlTG9nb3V0VXJsKG9wdGlvbnMpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGZvcm0gdG8gc2VuZCBQT1NUIHJlcXVlc3QuXG4gICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJylcblxuICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZSgnbWV0aG9kJywgJ1BPU1QnKVxuICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgdGhpcy5jcmVhdGVMb2dvdXRVcmwob3B0aW9ucykpXG4gICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgICAgIC8vIEFkZCBkYXRhIHRvIGZvcm0gYXMgaGlkZGVuIGlucHV0IGZpZWxkcy5cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICBpZF90b2tlbl9oaW50OiB0aGlzLmlkVG9rZW4sXG4gICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmkob3B0aW9ucylcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuXG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2hpZGRlbicpXG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCduYW1lJywgbmFtZSlcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh2YWx1ZSkpXG5cbiAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGZvcm0gdG8gcGFnZSBhbmQgc3VibWl0IGl0IHRvIHBlcmZvcm0gbG9nb3V0IGFuZCByZWRpcmVjdC5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKVxuICAgICAgICBmb3JtLnN1Ym1pdCgpXG4gICAgICB9LFxuXG4gICAgICByZWdpc3RlcjogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhd2FpdCB0aGlzLmNyZWF0ZVJlZ2lzdGVyVXJsKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9LFxuXG4gICAgICBhY2NvdW50TWFuYWdlbWVudDogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50VXJsID0gdGhpcy5jcmVhdGVBY2NvdW50VXJsKClcbiAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50VXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYWNjb3VudFVybFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXInKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH0sXG5cbiAgICAgIHJlZGlyZWN0VXJpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtLZXljbG9ha0FkYXB0ZXJ9XG4gICAqL1xuICAjbG9hZENvcmRvdmFBZGFwdGVyICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9naW5VcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7V2luZG93UHJveHkgfCBudWxsfVxuICAgICAqL1xuICAgIGNvbnN0IGNvcmRvdmFPcGVuV2luZG93V3JhcHBlciA9IChsb2dpblVybCwgdGFyZ2V0LCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAod2luZG93LmNvcmRvdmEgJiYgd2luZG93LmNvcmRvdmEuSW5BcHBCcm93c2VyKSB7XG4gICAgICAgIC8vIFVzZSBpbmFwcGJyb3dzZXIgZm9yIElPUyBhbmQgQW5kcm9pZCBpZiBhdmFpbGFibGVcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jb3Jkb3ZhLkluQXBwQnJvd3Nlci5vcGVuKGxvZ2luVXJsLCB0YXJnZXQsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gd2luZG93Lm9wZW4obG9naW5VcmwsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzaGFsbG93Q2xvbmVDb3Jkb3ZhT3B0aW9ucyA9ICh1c2VyT3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLmNvcmRvdmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh1c2VyT3B0aW9ucy5jb3Jkb3ZhT3B0aW9ucykucmVkdWNlKChvcHRpb25zLCBvcHRpb25OYW1lKSA9PiB7XG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHVzZXJPcHRpb25zLmNvcmRvdmFPcHRpb25zW29wdGlvbk5hbWVdXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICAgICAgfSwge30pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRDb3Jkb3ZhT3B0aW9ucyA9IChjb3Jkb3ZhT3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvcmRvdmFPcHRpb25zKS5yZWR1Y2UoKG9wdGlvbnMsIG9wdGlvbk5hbWUpID0+IHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbk5hbWUgKyAnPScgKyBjb3Jkb3ZhT3B0aW9uc1tvcHRpb25OYW1lXSlcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNcbiAgICAgIH0sIFtdKS5qb2luKCcsJylcbiAgICB9XG5cbiAgICBjb25zdCBjcmVhdGVDb3Jkb3ZhT3B0aW9ucyA9ICh1c2VyT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY29yZG92YU9wdGlvbnMgPSBzaGFsbG93Q2xvbmVDb3Jkb3ZhT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgICAgIGNvcmRvdmFPcHRpb25zLmxvY2F0aW9uID0gJ25vJ1xuICAgICAgaWYgKHVzZXJPcHRpb25zICYmIHVzZXJPcHRpb25zLnByb21wdCA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvcmRvdmFPcHRpb25zLmhpZGRlbiA9ICd5ZXMnXG4gICAgICB9XG4gICAgICByZXR1cm4gZm9ybWF0Q29yZG92YU9wdGlvbnMoY29yZG92YU9wdGlvbnMpXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q29yZG92YVJlZGlyZWN0VXJpID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RVcmkgfHwgJ2h0dHA6Ly9sb2NhbGhvc3QnXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZ2luOiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBjb3Jkb3ZhT3B0aW9ucyA9IGNyZWF0ZUNvcmRvdmFPcHRpb25zKG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGxvZ2luVXJsID0gYXdhaXQgdGhpcy5jcmVhdGVMb2dpblVybChvcHRpb25zKVxuICAgICAgICBjb25zdCByZWYgPSBjb3Jkb3ZhT3BlbldpbmRvd1dyYXBwZXIobG9naW5VcmwsICdfYmxhbmsnLCBjb3Jkb3ZhT3B0aW9ucylcbiAgICAgICAgbGV0IGNvbXBsZXRlZCA9IGZhbHNlXG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlQnJvd3NlciAoKSB7XG4gICAgICAgICAgY2xvc2VkID0gdHJ1ZVxuICAgICAgICAgIHJlZi5jbG9zZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YoZ2V0Q29yZG92YVJlZGlyZWN0VXJpKCkpID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy4jcGFyc2VDYWxsYmFjayhldmVudC51cmwpXG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm9jZXNzQ2FsbGJhY2soY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNsb3NlQnJvd3NlcigpXG4gICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlcnJvcicsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy4jcGFyc2VDYWxsYmFjayhldmVudC51cmwpXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb2Nlc3NDYWxsYmFjayhjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb3NlQnJvd3NlcigpXG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwcm9jZXNzIGxvZ2luLicpKVxuICAgICAgICAgICAgICAgIGNsb3NlQnJvd3NlcigpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2V4aXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgY2xvc2VkIHRoZSBsb2dpbiB3aW5kb3cuJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIGxvZ291dDogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgbG9nb3V0VXJsID0gdGhpcy5jcmVhdGVMb2dvdXRVcmwob3B0aW9ucylcbiAgICAgICAgY29uc3QgcmVmID0gY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyKGxvZ291dFVybCwgJ19ibGFuaycsICdsb2NhdGlvbj1ubyxoaWRkZW49eWVzLGNsZWFyY2FjaGU9eWVzJylcbiAgICAgICAgbGV0IGVycm9yID0gZmFsc2VcblxuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PT0gMCkge1xuICAgICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlcnJvcicsIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC51cmwuaW5kZXhPZihnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkoKSkgPT09IDApIHtcbiAgICAgICAgICAgIHJlZi5jbG9zZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0gdHJ1ZVxuICAgICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdleGl0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgY2xvc2VkIHRoZSBsb2dpbiB3aW5kb3cuJykpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNsZWFyVG9rZW4oKVxuICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgcmVnaXN0ZXI6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVXJsID0gYXdhaXQgdGhpcy5jcmVhdGVSZWdpc3RlclVybCgpXG4gICAgICAgIGNvbnN0IGNvcmRvdmFPcHRpb25zID0gY3JlYXRlQ29yZG92YU9wdGlvbnMob3B0aW9ucylcbiAgICAgICAgY29uc3QgcmVmID0gY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyKHJlZ2lzdGVyVXJsLCAnX2JsYW5rJywgY29yZG92YU9wdGlvbnMpXG5cbiAgICAgICAgLyoqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fSAqL1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC51cmwuaW5kZXhPZihnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkoKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgICAgICAgY29uc3Qgb2F1dGggPSB0aGlzLiNwYXJzZUNhbGxiYWNrKGV2ZW50LnVybClcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb2Nlc3NDYWxsYmFjayhvYXV0aClcbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IHByb21pc2VcbiAgICAgIH0sXG5cbiAgICAgIGFjY291bnRNYW5hZ2VtZW50OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRVcmwgPSB0aGlzLmNyZWF0ZUFjY291bnRVcmwoKVxuICAgICAgICBpZiAodHlwZW9mIGFjY291bnRVcmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc3QgcmVmID0gY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyKGFjY291bnRVcmwsICdfYmxhbmsnLCAnbG9jYXRpb249bm8nKVxuICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC51cmwuaW5kZXhPZihnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkoKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXInKVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZWRpcmVjdFVyaTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0Q29yZG92YVJlZGlyZWN0VXJpKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0tleWNsb2FrQWRhcHRlcn1cbiAgICovXG4gICNsb2FkQ29yZG92YU5hdGl2ZUFkYXB0ZXIgKCkge1xuICAgIC8qIGdsb2JhbCB1bml2ZXJzYWxMaW5rcyAqL1xuICAgIHJldHVybiB7XG4gICAgICBsb2dpbjogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgbG9naW5VcmwgPSBhd2FpdCB0aGlzLmNyZWF0ZUxvZ2luVXJsKG9wdGlvbnMpXG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHVuaXZlcnNhbExpbmtzLnN1YnNjcmliZSgna2V5Y2xvYWsnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVuaXZlcnNhbExpbmtzLnVuc3Vic2NyaWJlKCdrZXljbG9haycpXG4gICAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuY2xvc2UoKVxuICAgICAgICAgICAgY29uc3Qgb2F1dGggPSB0aGlzLiNwYXJzZUNhbGxiYWNrKGV2ZW50LnVybClcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKG9hdXRoKVxuICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmwobG9naW5VcmwpXG4gICAgICAgIH0pXG4gICAgICB9LFxuXG4gICAgICBsb2dvdXQ6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvZ291dFVybCA9IHRoaXMuY3JlYXRlTG9nb3V0VXJsKG9wdGlvbnMpXG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICB1bml2ZXJzYWxMaW5rcy5zdWJzY3JpYmUoJ2tleWNsb2FrJywgKCkgPT4ge1xuICAgICAgICAgICAgdW5pdmVyc2FsTGlua3MudW5zdWJzY3JpYmUoJ2tleWNsb2FrJylcbiAgICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5jbG9zZSgpXG4gICAgICAgICAgICB0aGlzLmNsZWFyVG9rZW4oKVxuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsKGxvZ291dFVybClcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIHJlZ2lzdGVyOiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZWdpc3RlclVybCA9IGF3YWl0IHRoaXMuY3JlYXRlUmVnaXN0ZXJVcmwob3B0aW9ucylcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdW5pdmVyc2FsTGlua3Muc3Vic2NyaWJlKCdrZXljbG9haycsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdW5pdmVyc2FsTGlua3MudW5zdWJzY3JpYmUoJ2tleWNsb2FrJylcbiAgICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5jbG9zZSgpXG4gICAgICAgICAgICBjb25zdCBvYXV0aCA9IHRoaXMuI3BhcnNlQ2FsbGJhY2soZXZlbnQudXJsKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKG9hdXRoKVxuICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmwocmVnaXN0ZXJVcmwpXG4gICAgICAgIH0pXG4gICAgICB9LFxuXG4gICAgICBhY2NvdW50TWFuYWdlbWVudDogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50VXJsID0gdGhpcy5jcmVhdGVBY2NvdW50VXJsKClcbiAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50VXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsKGFjY291bnRVcmwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBPSURDIHNlcnZlcicpXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlZGlyZWN0VXJpOiAob3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlZGlyZWN0VXJpKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlZGlyZWN0VXJpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RVcmlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ2h0dHA6Ly9sb2NhbGhvc3QnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyAjbG9hZENvbmZpZyAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLiNjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBqc29uQ29uZmlnID0gYXdhaXQgZmV0Y2hKc29uQ29uZmlnKHRoaXMuI2NvbmZpZylcbiAgICAgIHRoaXMuYXV0aFNlcnZlclVybCA9IGpzb25Db25maWdbJ2F1dGgtc2VydmVyLXVybCddXG4gICAgICB0aGlzLnJlYWxtID0ganNvbkNvbmZpZy5yZWFsbVxuICAgICAgdGhpcy5jbGllbnRJZCA9IGpzb25Db25maWcucmVzb3VyY2VcbiAgICAgIHRoaXMuI3NldHVwRW5kcG9pbnRzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGllbnRJZCA9IHRoaXMuI2NvbmZpZy5jbGllbnRJZFxuXG4gICAgICBpZiAoJ29pZGNQcm92aWRlcicgaW4gdGhpcy4jY29uZmlnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2xvYWRPaWRjQ29uZmlnKHRoaXMuI2NvbmZpZy5vaWRjUHJvdmlkZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF1dGhTZXJ2ZXJVcmwgPSB0aGlzLiNjb25maWcudXJsXG4gICAgICAgIHRoaXMucmVhbG0gPSB0aGlzLiNjb25maWcucmVhbG1cbiAgICAgICAgdGhpcy4jc2V0dXBFbmRwb2ludHMoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gICNzZXR1cEVuZHBvaW50cyAoKSB7XG4gICAgdGhpcy5lbmRwb2ludHMgPSB7XG4gICAgICBhdXRob3JpemU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0L2F1dGgnXG4gICAgICB9LFxuICAgICAgdG9rZW46ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0L3Rva2VuJ1xuICAgICAgfSxcbiAgICAgIGxvZ291dDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvbG9nb3V0J1xuICAgICAgfSxcbiAgICAgIGNoZWNrU2Vzc2lvbklmcmFtZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvbG9naW4tc3RhdHVzLWlmcmFtZS5odG1sJ1xuICAgICAgfSxcbiAgICAgIHRoaXJkUGFydHlDb29raWVzSWZyYW1lOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRSZWFsbVVybCgpICsgJy9wcm90b2NvbC9vcGVuaWQtY29ubmVjdC8zcC1jb29raWVzL3N0ZXAxLmh0bWwnXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXI6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0L3JlZ2lzdHJhdGlvbnMnXG4gICAgICB9LFxuICAgICAgdXNlcmluZm86ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0L3VzZXJpbmZvJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IE9wZW5JZFByb3ZpZGVyTWV0YWRhdGF9IG9pZGNQcm92aWRlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNsb2FkT2lkY0NvbmZpZyAob2lkY1Byb3ZpZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvaWRjUHJvdmlkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB1cmwgPSBgJHtzdHJpcFRyYWlsaW5nU2xhc2gob2lkY1Byb3ZpZGVyKX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gXG4gICAgICBjb25zdCBvcGVuSWRDb25maWcgPSBhd2FpdCBmZXRjaE9wZW5JZENvbmZpZyh1cmwpXG4gICAgICB0aGlzLiNzZXR1cE9pZGNFbmRwb2ludHMob3BlbklkQ29uZmlnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNzZXR1cE9pZGNFbmRwb2ludHMob2lkY1Byb3ZpZGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wZW5JZFByb3ZpZGVyTWV0YWRhdGF9IGNvbmZpZ1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gICNzZXR1cE9pZGNFbmRwb2ludHMgKGNvbmZpZykge1xuICAgIHRoaXMuZW5kcG9pbnRzID0ge1xuICAgICAgYXV0aG9yaXplICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5hdXRob3JpemF0aW9uX2VuZHBvaW50XG4gICAgICB9LFxuICAgICAgdG9rZW4gKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLnRva2VuX2VuZHBvaW50XG4gICAgICB9LFxuICAgICAgbG9nb3V0ICgpIHtcbiAgICAgICAgaWYgKCFjb25maWcuZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLmVuZF9zZXNzaW9uX2VuZHBvaW50XG4gICAgICB9LFxuICAgICAgY2hlY2tTZXNzaW9uSWZyYW1lICgpIHtcbiAgICAgICAgaWYgKCFjb25maWcuY2hlY2tfc2Vzc2lvbl9pZnJhbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLmNoZWNrX3Nlc3Npb25faWZyYW1lXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXIgKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZGlyZWN0aW9uIHRvIFwiUmVnaXN0ZXIgdXNlclwiIHBhZ2Ugbm90IHN1cHBvcnRlZCBpbiBzdGFuZGFyZCBPSURDIG1vZGUnKVxuICAgICAgfSxcbiAgICAgIHVzZXJpbmZvICgpIHtcbiAgICAgICAgaWYgKCFjb25maWcudXNlcmluZm9fZW5kcG9pbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnVzZXJpbmZvX2VuZHBvaW50XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI2NoZWNrM3BDb29raWVzU3VwcG9ydGVkICgpIHtcbiAgICBpZiAoKCF0aGlzLiNsb2dpbklmcmFtZS5lbmFibGUgJiYgIXRoaXMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSkgfHwgdHlwZW9mIHRoaXMuZW5kcG9pbnRzLnRoaXJkUGFydHlDb29raWVzSWZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuZW5kcG9pbnRzLnRoaXJkUGFydHlDb29raWVzSWZyYW1lKCkpXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc2FuZGJveCcsICdhbGxvdy1zdG9yYWdlLWFjY2Vzcy1ieS11c2VyLWFjdGl2YXRpb24gYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpbicpXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAna2V5Y2xvYWstM3AtY2hlY2staWZyYW1lJylcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKVxuXG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fSAqL1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgY29uc3QgbWVzc2FnZUNhbGxiYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudFdpbmRvdyAhPT0gZXZlbnQuc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGF0YSAhPT0gJ3N1cHBvcnRlZCcgJiYgZXZlbnQuZGF0YSAhPT0gJ3Vuc3VwcG9ydGVkJykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEgPT09ICd1bnN1cHBvcnRlZCcpIHtcbiAgICAgICAgICB0aGlzLiNsb2dXYXJuKFxuICAgICAgICAgICAgJ1tLRVlDTE9BS10gWW91ciBicm93c2VyIGlzIGJsb2NraW5nIGFjY2VzcyB0byAzcmQtcGFydHkgY29va2llcywgdGhpcyBtZWFuczpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgLSBJdCBpcyBub3QgcG9zc2libGUgdG8gcmV0cmlldmUgdG9rZW5zIHdpdGhvdXQgcmVkaXJlY3RpbmcgdG8gdGhlIEtleWNsb2FrIHNlcnZlciAoYS5rLmEuIG5vIHN1cHBvcnQgZm9yIHNpbGVudCBhdXRoZW50aWNhdGlvbikuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIC0gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIHNlc3Npb24gc3RhdHVzIChzdWNoIGFzIHRoZSB1c2VyIGxvZ2dpbmcgb3V0IGluIGFub3RoZXIgdGFiKS5cXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWU6IGh0dHBzOi8vd3d3LmtleWNsb2FrLm9yZy9zZWN1cmluZy1hcHBzL2phdmFzY3JpcHQtYWRhcHRlciNfbW9kZXJuX2Jyb3dzZXJzJ1xuICAgICAgICAgIClcblxuICAgICAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSA9IGZhbHNlXG4gICAgICAgICAgaWYgKHRoaXMuc2lsZW50Q2hlY2tTc29GYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZUNhbGxiYWNrKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlQ2FsbGJhY2ssIGZhbHNlKVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXdhaXQgYXBwbHlUaW1lb3V0VG9Qcm9taXNlKHByb21pc2UsIHRoaXMubWVzc2FnZVJlY2VpdmVUaW1lb3V0LCAnVGltZW91dCB3aGVuIHdhaXRpbmcgZm9yIDNyZCBwYXJ0eSBjaGVjayBpZnJhbWUgbWVzc2FnZS4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtJbml0T3B0aW9uc30gaW5pdE9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyAjcHJvY2Vzc0luaXQgKGluaXRPcHRpb25zKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLiNwYXJzZUNhbGxiYWNrKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgaWYgKGNhbGxiYWNrPy5yZWRpcmVjdFVyaSkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgY2FsbGJhY2sucmVkaXJlY3RVcmkpXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLnZhbGlkKSB7XG4gICAgICBhd2FpdCB0aGlzLiNzZXR1cENoZWNrTG9naW5JZnJhbWUoKVxuICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKGNhbGxiYWNrKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvbXB0ICovXG4gICAgY29uc3QgZG9Mb2dpbiA9IGFzeW5jIChwcm9tcHQpID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7S2V5Y2xvYWtMb2dpbk9wdGlvbnN9ICovXG4gICAgICBjb25zdCBvcHRpb25zID0ge31cblxuICAgICAgaWYgKCFwcm9tcHQpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9tcHQgPSAnbm9uZSdcbiAgICAgIH1cblxuICAgICAgaWYgKGluaXRPcHRpb25zLmxvY2FsZSkge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGluaXRPcHRpb25zLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLmxvZ2luKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgY29uc3Qgb25Mb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgc3dpdGNoIChpbml0T3B0aW9ucy5vbkxvYWQpIHtcbiAgICAgICAgY2FzZSAnY2hlY2stc3NvJzpcbiAgICAgICAgICBpZiAodGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXR1cENoZWNrTG9naW5JZnJhbWUoKVxuICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkID0gYXdhaXQgdGhpcy4jY2hlY2tMb2dpbklmcmFtZSgpXG5cbiAgICAgICAgICAgIGlmICghdW5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSA/IGF3YWl0IHRoaXMuI2NoZWNrU3NvU2lsZW50bHkoKSA6IGF3YWl0IGRvTG9naW4oZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSA/IGF3YWl0IHRoaXMuI2NoZWNrU3NvU2lsZW50bHkoKSA6IGF3YWl0IGRvTG9naW4oZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2xvZ2luLXJlcXVpcmVkJzpcbiAgICAgICAgICBhd2FpdCBkb0xvZ2luKHRydWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIG9uTG9hZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLnRva2VuICYmIGluaXRPcHRpb25zLnJlZnJlc2hUb2tlbikge1xuICAgICAgdGhpcy4jc2V0VG9rZW4oaW5pdE9wdGlvbnMudG9rZW4sIGluaXRPcHRpb25zLnJlZnJlc2hUb2tlbiwgaW5pdE9wdGlvbnMuaWRUb2tlbilcblxuICAgICAgaWYgKHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNzZXR1cENoZWNrTG9naW5JZnJhbWUoKVxuICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSBhd2FpdCB0aGlzLiNjaGVja0xvZ2luSWZyYW1lKClcblxuICAgICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhTdWNjZXNzPy4oKVxuICAgICAgICAgIHRoaXMuI3NjaGVkdWxlQ2hlY2tJZnJhbWUoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlVG9rZW4oLTEpXG4gICAgICAgICAgdGhpcy5vbkF1dGhTdWNjZXNzPy4oKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMub25BdXRoRXJyb3I/LigpXG4gICAgICAgICAgaWYgKGluaXRPcHRpb25zLm9uTG9hZCkge1xuICAgICAgICAgICAgYXdhaXQgb25Mb2FkKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluaXRPcHRpb25zLm9uTG9hZCkge1xuICAgICAgYXdhaXQgb25Mb2FkKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyAjc2V0dXBDaGVja0xvZ2luSWZyYW1lICgpIHtcbiAgICBpZiAoIXRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSB8fCB0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgdGhpcy4jbG9naW5JZnJhbWUuaWZyYW1lID0gaWZyYW1lXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5lbmRwb2ludHMuY2hlY2tTZXNzaW9uSWZyYW1lKCkpXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc2FuZGJveCcsICdhbGxvdy1zdG9yYWdlLWFjY2Vzcy1ieS11c2VyLWFjdGl2YXRpb24gYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpbicpXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAna2V5Y2xvYWstc2Vzc2lvbi1pZnJhbWUnKVxuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBjb25zdCBtZXNzYWdlQ2FsbGJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZU9yaWdpbiB8fCB0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWU/LmNvbnRlbnRXaW5kb3cgIT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCEoZXZlbnQuZGF0YSA9PT0gJ3VuY2hhbmdlZCcgfHwgZXZlbnQuZGF0YSA9PT0gJ2NoYW5nZWQnIHx8IGV2ZW50LmRhdGEgPT09ICdlcnJvcicpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuZGF0YSAhPT0gJ3VuY2hhbmdlZCcpIHtcbiAgICAgICAgdGhpcy5jbGVhclRva2VuKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy4jbG9naW5JZnJhbWUuY2FsbGJhY2tMaXN0XG4gICAgICB0aGlzLiNsb2dpbklmcmFtZS5jYWxsYmFja0xpc3QgPSBbXVxuXG4gICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcy5yZXZlcnNlKCkpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIGxvZ2luIGlmcmFtZScpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGV2ZW50LmRhdGEgPT09ICd1bmNoYW5nZWQnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlQ2FsbGJhY2ssIGZhbHNlKVxuXG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fSAqL1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhVcmwgPSB0aGlzLmVuZHBvaW50cy5hdXRob3JpemUoKVxuICAgICAgICBpZiAoYXV0aFVybC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICB0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWVPcmlnaW4gPSBnbG9iYWxUaGlzLmxvY2F0aW9uLm9yaWdpblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZU9yaWdpbiA9IG5ldyBVUkwoYXV0aFVybCkub3JpZ2luXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBhd2FpdCBwcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbiB8IHVuZGVmaW5lZD59XG4gICAqL1xuICBhc3luYyAjY2hlY2tMb2dpbklmcmFtZSAoKSB7XG4gICAgaWYgKCF0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWUgfHwgIXRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZU9yaWdpbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IGAke3RoaXMuY2xpZW50SWR9ICR7KHRoaXMuc2Vzc2lvbklkID8gdGhpcy5zZXNzaW9uSWQgOiAnJyl9YFxuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZU9yaWdpblxuXG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPGJvb2xlYW4+fSAqL1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvKiogQHR5cGUgeyhlcnJvcjogRXJyb3IgfCBudWxsLCB2YWx1ZT86IGJvb2xlYW4pID0+IHZvaWR9ICovXG4gICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHJlc3VsdCkpXG5cbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmNhbGxiYWNrTGlzdC5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICBpZiAodGhpcy4jbG9naW5JZnJhbWUuY2FsbGJhY2tMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWU/LmNvbnRlbnRXaW5kb3c/LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNjaGVja1Nzb1NpbGVudGx5ICgpIHtcbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgIGNvbnN0IHNyYyA9IGF3YWl0IHRoaXMuY3JlYXRlTG9naW5VcmwoeyBwcm9tcHQ6ICdub25lJywgcmVkaXJlY3RVcmk6IHRoaXMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSB9KVxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYylcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJ2FsbG93LXN0b3JhZ2UtYWNjZXNzLWJ5LXVzZXItYWN0aXZhdGlvbiBhbGxvdy1zY3JpcHRzIGFsbG93LXNhbWUtb3JpZ2luJylcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd0aXRsZScsICdrZXljbG9hay1zaWxlbnQtY2hlY2stc3NvJylcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKVxuXG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG1lc3NhZ2VDYWxsYmFjayA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IGlmcmFtZS5jb250ZW50V2luZG93ICE9PSBldmVudC5zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9hdXRoID0gdGhpcy4jcGFyc2VDYWxsYmFjayhldmVudC5kYXRhKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKG9hdXRoKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VDYWxsYmFjaylcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlQ2FsbGJhY2spXG4gICAgfSlcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgI3BhcnNlQ2FsbGJhY2sgKHVybCkge1xuICAgIGNvbnN0IG9hdXRoID0gdGhpcy4jcGFyc2VDYWxsYmFja1VybCh1cmwpXG4gICAgaWYgKCFvYXV0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgb2F1dGhTdGF0ZSA9IHRoaXMuI2NhbGxiYWNrU3RvcmFnZS5nZXQob2F1dGguc3RhdGUpXG5cbiAgICBpZiAob2F1dGhTdGF0ZSkge1xuICAgICAgb2F1dGgudmFsaWQgPSB0cnVlXG4gICAgICBvYXV0aC5yZWRpcmVjdFVyaSA9IG9hdXRoU3RhdGUucmVkaXJlY3RVcmlcbiAgICAgIG9hdXRoLnN0b3JlZE5vbmNlID0gb2F1dGhTdGF0ZS5ub25jZVxuICAgICAgb2F1dGgucHJvbXB0ID0gb2F1dGhTdGF0ZS5wcm9tcHRcbiAgICAgIG9hdXRoLnBrY2VDb2RlVmVyaWZpZXIgPSBvYXV0aFN0YXRlLnBrY2VDb2RlVmVyaWZpZXJcbiAgICAgIG9hdXRoLmxvZ2luT3B0aW9ucyA9IG9hdXRoU3RhdGUubG9naW5PcHRpb25zXG4gICAgfVxuXG4gICAgcmV0dXJuIG9hdXRoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFN0cmluZ1xuICAgKi9cbiAgI3BhcnNlQ2FsbGJhY2tVcmwgKHVybFN0cmluZykge1xuICAgIGxldCBzdXBwb3J0ZWRQYXJhbXMgPSBbXVxuICAgIHN3aXRjaCAodGhpcy5mbG93KSB7XG4gICAgICBjYXNlICdzdGFuZGFyZCc6XG4gICAgICAgIHN1cHBvcnRlZFBhcmFtcyA9IFsnY29kZScsICdzdGF0ZScsICdzZXNzaW9uX3N0YXRlJywgJ2tjX2FjdGlvbl9zdGF0dXMnLCAna2NfYWN0aW9uJywgJ2lzcyddXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgIHN1cHBvcnRlZFBhcmFtcyA9IFsnYWNjZXNzX3Rva2VuJywgJ3Rva2VuX3R5cGUnLCAnaWRfdG9rZW4nLCAnc3RhdGUnLCAnc2Vzc2lvbl9zdGF0ZScsICdleHBpcmVzX2luJywgJ2tjX2FjdGlvbl9zdGF0dXMnLCAna2NfYWN0aW9uJywgJ2lzcyddXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdoeWJyaWQnOlxuICAgICAgICBzdXBwb3J0ZWRQYXJhbXMgPSBbJ2FjY2Vzc190b2tlbicsICd0b2tlbl90eXBlJywgJ2lkX3Rva2VuJywgJ2NvZGUnLCAnc3RhdGUnLCAnc2Vzc2lvbl9zdGF0ZScsICdleHBpcmVzX2luJywgJ2tjX2FjdGlvbl9zdGF0dXMnLCAna2NfYWN0aW9uJywgJ2lzcyddXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgc3VwcG9ydGVkUGFyYW1zLnB1c2goJ2Vycm9yJylcbiAgICBzdXBwb3J0ZWRQYXJhbXMucHVzaCgnZXJyb3JfZGVzY3JpcHRpb24nKVxuICAgIHN1cHBvcnRlZFBhcmFtcy5wdXNoKCdlcnJvcl91cmknKVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxTdHJpbmcpXG4gICAgbGV0IHJlZGlyZWN0VXJpID0gJydcbiAgICBsZXQgcGFyc2VkXG5cbiAgICBpZiAodGhpcy5yZXNwb25zZU1vZGUgPT09ICdxdWVyeScgJiYgdXJsLnNlYXJjaFBhcmFtcy5zaXplID4gMCkge1xuICAgICAgcGFyc2VkID0gdGhpcy4jcGFyc2VDYWxsYmFja1BhcmFtcyh1cmwuc2VhcmNoLCBzdXBwb3J0ZWRQYXJhbXMpXG4gICAgICB1cmwuc2VhcmNoID0gcGFyc2VkLnBhcmFtc1N0cmluZ1xuICAgICAgcmVkaXJlY3RVcmkgPSB1cmwudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAodGhpcy5yZXNwb25zZU1vZGUgPT09ICdmcmFnbWVudCcgJiYgdXJsLmhhc2gubGVuZ3RoID4gMCkge1xuICAgICAgcGFyc2VkID0gdGhpcy4jcGFyc2VDYWxsYmFja1BhcmFtcyh1cmwuaGFzaC5zdWJzdHJpbmcoMSksIHN1cHBvcnRlZFBhcmFtcylcbiAgICAgIHVybC5oYXNoID0gJydcbiAgICAgIHJlZGlyZWN0VXJpID0gdXJsLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkPy5vYXV0aFBhcmFtcykge1xuICAgICAgaWYgKHRoaXMuZmxvdyA9PT0gJ3N0YW5kYXJkJyB8fCB0aGlzLmZsb3cgPT09ICdoeWJyaWQnKSB7XG4gICAgICAgIGlmICgocGFyc2VkLm9hdXRoUGFyYW1zLmNvZGUgfHwgcGFyc2VkLm9hdXRoUGFyYW1zLmVycm9yKSAmJiBwYXJzZWQub2F1dGhQYXJhbXMuc3RhdGUpIHtcbiAgICAgICAgICBwYXJzZWQub2F1dGhQYXJhbXMucmVkaXJlY3RVcmkgPSByZWRpcmVjdFVyaVxuICAgICAgICAgIHJldHVybiBwYXJzZWQub2F1dGhQYXJhbXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZsb3cgPT09ICdpbXBsaWNpdCcpIHtcbiAgICAgICAgaWYgKChwYXJzZWQub2F1dGhQYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcnNlZC5vYXV0aFBhcmFtcy5lcnJvcikgJiYgcGFyc2VkLm9hdXRoUGFyYW1zLnN0YXRlKSB7XG4gICAgICAgICAgcGFyc2VkLm9hdXRoUGFyYW1zLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmlcbiAgICAgICAgICByZXR1cm4gcGFyc2VkLm9hdXRoUGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VkQ2FsbGJhY2tQYXJhbXNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBhcmFtc1N0cmluZ1xuICAgKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD59IG9hdXRoUGFyYW1zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zU3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHN1cHBvcnRlZFBhcmFtc1xuICAgKiBAcmV0dXJucyB7UGFyc2VkQ2FsbGJhY2tQYXJhbXN9XG4gICAqL1xuICAjcGFyc2VDYWxsYmFja1BhcmFtcyAocGFyYW1zU3RyaW5nLCBzdXBwb3J0ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtc1N0cmluZylcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgY29uc3Qgb2F1dGhQYXJhbXMgPSB7fVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgQXJyYXkuZnJvbShwYXJhbXMuZW50cmllcygpKSkge1xuICAgICAgaWYgKHN1cHBvcnRlZFBhcmFtcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIG9hdXRoUGFyYW1zW2tleV0gPSB2YWx1ZVxuICAgICAgICBwYXJhbXMuZGVsZXRlKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyYW1zU3RyaW5nOiBwYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgIG9hdXRoUGFyYW1zXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3Byb2Nlc3NDYWxsYmFjayAob2F1dGgpIHtcbiAgICBjb25zdCB7IGNvZGUsIGVycm9yLCBwcm9tcHQgfSA9IG9hdXRoXG4gICAgbGV0IHRpbWVMb2NhbCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHJlZnJlc2hUb2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaWRUb2tlblxuICAgICAqL1xuICAgIGNvbnN0IGF1dGhTdWNjZXNzID0gKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGlkVG9rZW4pID0+IHtcbiAgICAgIHRpbWVMb2NhbCA9ICh0aW1lTG9jYWwgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLyAyXG5cbiAgICAgIHRoaXMuI3NldFRva2VuKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGlkVG9rZW4sIHRpbWVMb2NhbClcblxuICAgICAgaWYgKHRoaXMuI3VzZU5vbmNlICYmICh0aGlzLmlkVG9rZW5QYXJzZWQgJiYgdGhpcy5pZFRva2VuUGFyc2VkLm5vbmNlICE9PSBvYXV0aC5zdG9yZWROb25jZSkpIHtcbiAgICAgICAgdGhpcy4jbG9nSW5mbygnW0tFWUNMT0FLXSBJbnZhbGlkIG5vbmNlLCBjbGVhcmluZyB0b2tlbicpXG4gICAgICAgIHRoaXMuY2xlYXJUb2tlbigpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub25jZS4nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYXV0aC5rY19hY3Rpb25fc3RhdHVzKSB7XG4gICAgICB0aGlzLm9uQWN0aW9uVXBkYXRlICYmIHRoaXMub25BY3Rpb25VcGRhdGUob2F1dGgua2NfYWN0aW9uX3N0YXR1cywgb2F1dGgua2NfYWN0aW9uKVxuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaWYgKHByb21wdCAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmIChvYXV0aC5lcnJvcl9kZXNjcmlwdGlvbiAmJiBvYXV0aC5lcnJvcl9kZXNjcmlwdGlvbiA9PT0gJ2F1dGhlbnRpY2F0aW9uX2V4cGlyZWQnKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5sb2dpbihvYXV0aC5sb2dpbk9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0geyBlcnJvciwgZXJyb3JfZGVzY3JpcHRpb246IG9hdXRoLmVycm9yX2Rlc2NyaXB0aW9uIH1cbiAgICAgICAgICB0aGlzLm9uQXV0aEVycm9yPy4oZXJyb3JEYXRhKVxuICAgICAgICAgIHRocm93IGVycm9yRGF0YVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2UgaWYgKCh0aGlzLmZsb3cgIT09ICdzdGFuZGFyZCcpICYmIChvYXV0aC5hY2Nlc3NfdG9rZW4gfHwgb2F1dGguaWRfdG9rZW4pKSB7XG4gICAgICBhdXRoU3VjY2VzcyhvYXV0aC5hY2Nlc3NfdG9rZW4sIHVuZGVmaW5lZCwgb2F1dGguaWRfdG9rZW4pXG4gICAgICB0aGlzLm9uQXV0aFN1Y2Nlc3M/LigpXG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLmZsb3cgIT09ICdpbXBsaWNpdCcpICYmIGNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBY2Nlc3NUb2tlbih0aGlzLmVuZHBvaW50cy50b2tlbigpLCBjb2RlLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMuY2xpZW50SWQpLCBvYXV0aC5yZWRpcmVjdFVyaSwgb2F1dGgucGtjZUNvZGVWZXJpZmllcilcbiAgICAgICAgYXV0aFN1Y2Nlc3MocmVzcG9uc2UuYWNjZXNzX3Rva2VuLCByZXNwb25zZS5yZWZyZXNoX3Rva2VuLCByZXNwb25zZS5pZF90b2tlbilcblxuICAgICAgICBpZiAodGhpcy5mbG93ID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhTdWNjZXNzPy4oKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jc2NoZWR1bGVDaGVja0lmcmFtZSgpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLm9uQXV0aEVycm9yPy4oKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jICNzY2hlZHVsZUNoZWNrSWZyYW1lICgpIHtcbiAgICBpZiAodGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlICYmIHRoaXMudG9rZW4pIHtcbiAgICAgIGF3YWl0IHdhaXRGb3JUaW1lb3V0KHRoaXMuI2xvZ2luSWZyYW1lLmludGVydmFsICogMTAwMClcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGF3YWl0IHRoaXMuI2NoZWNrTG9naW5JZnJhbWUoKVxuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3NjaGVkdWxlQ2hlY2tJZnJhbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrTG9naW5PcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBsb2dpbiAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiNhZGFwdGVyLmxvZ2luKG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtLZXljbG9ha0xvZ2luT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gICAqL1xuICBhc3luYyBjcmVhdGVMb2dpblVybCAob3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlVVVJRCgpXG4gICAgY29uc3Qgbm9uY2UgPSBjcmVhdGVVVUlEKClcbiAgICBjb25zdCByZWRpcmVjdFVyaSA9IHRoaXMuI2FkYXB0ZXIucmVkaXJlY3RVcmkob3B0aW9ucylcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrU3RhdGV9ICovXG4gICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IHtcbiAgICAgIHN0YXRlLFxuICAgICAgbm9uY2UsXG4gICAgICByZWRpcmVjdFVyaSxcbiAgICAgIGxvZ2luT3B0aW9uczogb3B0aW9uc1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5wcm9tcHQpIHtcbiAgICAgIGNhbGxiYWNrU3RhdGUucHJvbXB0ID0gb3B0aW9ucy5wcm9tcHRcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBvcHRpb25zPy5hY3Rpb24gPT09ICdyZWdpc3RlcidcbiAgICAgID8gdGhpcy5lbmRwb2ludHMucmVnaXN0ZXIoKVxuICAgICAgOiB0aGlzLmVuZHBvaW50cy5hdXRob3JpemUoKVxuXG4gICAgbGV0IHNjb3BlID0gb3B0aW9ucz8uc2NvcGUgfHwgdGhpcy5zY29wZVxuICAgIGNvbnN0IHNjb3BlVmFsdWVzID0gc2NvcGUgPyBzY29wZS5zcGxpdCgnICcpIDogW11cblxuICAgIC8vIEVuc3VyZSB0aGUgJ29wZW5pZCcgc2NvcGUgaXMgYWx3YXlzIGluY2x1ZGVkLlxuICAgIGlmICghc2NvcGVWYWx1ZXMuaW5jbHVkZXMoJ29wZW5pZCcpKSB7XG4gICAgICBzY29wZVZhbHVlcy51bnNoaWZ0KCdvcGVuaWQnKVxuICAgIH1cblxuICAgIHNjb3BlID0gc2NvcGVWYWx1ZXMuam9pbignICcpXG5cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAgICAgIFsnY2xpZW50X2lkJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLmNsaWVudElkKV0sXG4gICAgICAvLyBUaGUgZW5kcG9pbnQgVVJJIE1VU1QgTk9UIGluY2x1ZGUgYSBmcmFnbWVudCBjb21wb25lbnQuXG4gICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY3NDkjc2VjdGlvbi0zLjEuMlxuICAgICAgWydyZWRpcmVjdF91cmknLCBzdHJpcEhhc2gocmVkaXJlY3RVcmkpXSxcbiAgICAgIFsnc3RhdGUnLCBzdGF0ZV0sXG4gICAgICBbJ3Jlc3BvbnNlX21vZGUnLCB0aGlzLnJlc3BvbnNlTW9kZV0sXG4gICAgICBbJ3Jlc3BvbnNlX3R5cGUnLCB0aGlzLnJlc3BvbnNlVHlwZV0sXG4gICAgICBbJ3Njb3BlJywgc2NvcGVdXG4gICAgXSlcblxuICAgIGlmICh0aGlzLiN1c2VOb25jZSkge1xuICAgICAgcGFyYW1zLmFwcGVuZCgnbm9uY2UnLCBub25jZSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ucHJvbXB0KSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdwcm9tcHQnLCBvcHRpb25zLnByb21wdClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnM/Lm1heEFnZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ21heF9hZ2UnLCBvcHRpb25zLm1heEFnZS50b1N0cmluZygpKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dpbkhpbnQpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ2xvZ2luX2hpbnQnLCBvcHRpb25zLmxvZ2luSGludClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uaWRwSGludCkge1xuICAgICAgcGFyYW1zLmFwcGVuZCgna2NfaWRwX2hpbnQnLCBvcHRpb25zLmlkcEhpbnQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmFjdGlvbiAmJiBvcHRpb25zLmFjdGlvbiAhPT0gJ3JlZ2lzdGVyJykge1xuICAgICAgcGFyYW1zLmFwcGVuZCgna2NfYWN0aW9uJywgb3B0aW9ucy5hY3Rpb24pXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvY2FsZSkge1xuICAgICAgcGFyYW1zLmFwcGVuZCgndWlfbG9jYWxlcycsIG9wdGlvbnMubG9jYWxlKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5hY3IpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ2NsYWltcycsIGJ1aWxkQ2xhaW1zUGFyYW1ldGVyKG9wdGlvbnMuYWNyKSlcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uYWNyVmFsdWVzKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdhY3JfdmFsdWVzJywgb3B0aW9ucy5hY3JWYWx1ZXMpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGtjZU1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVDb2RlVmVyaWZpZXIoOTYpXG4gICAgICAgIGNvbnN0IHBrY2VDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBrY2VDaGFsbGVuZ2UodGhpcy5wa2NlTWV0aG9kLCBjb2RlVmVyaWZpZXIpXG5cbiAgICAgICAgY2FsbGJhY2tTdGF0ZS5wa2NlQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyXG5cbiAgICAgICAgcGFyYW1zLmFwcGVuZCgnY29kZV9jaGFsbGVuZ2UnLCBwa2NlQ2hhbGxlbmdlKVxuICAgICAgICBwYXJhbXMuYXBwZW5kKCdjb2RlX2NoYWxsZW5nZV9tZXRob2QnLCB0aGlzLnBrY2VNZXRob2QpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBQS0NFIGNoYWxsZW5nZS4nLCB7IGNhdXNlOiBlcnJvciB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2NhbGxiYWNrU3RvcmFnZS5hZGQoY2FsbGJhY2tTdGF0ZSlcblxuICAgIHJldHVybiBgJHt1cmx9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtMb2dvdXRPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBsb2dvdXQgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4jYWRhcHRlci5sb2dvdXQob3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrTG9nb3V0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjcmVhdGVMb2dvdXRVcmwgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dvdXRNZXRob2QgPSBvcHRpb25zPy5sb2dvdXRNZXRob2QgPz8gdGhpcy5sb2dvdXRNZXRob2RcbiAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50cy5sb2dvdXQoKVxuXG4gICAgaWYgKGxvZ291dE1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgICBbJ2NsaWVudF9pZCcsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jbGllbnRJZCldLFxuICAgICAgWydwb3N0X2xvZ291dF9yZWRpcmVjdF91cmknLCB0aGlzLiNhZGFwdGVyLnJlZGlyZWN0VXJpKG9wdGlvbnMpXVxuICAgIF0pXG5cbiAgICBpZiAodGhpcy5pZFRva2VuKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdpZF90b2tlbl9oaW50JywgdGhpcy5pZFRva2VuKVxuICAgIH1cblxuICAgIHJldHVybiBgJHt1cmx9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtSZWdpc3Rlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHJlZ2lzdGVyIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FkYXB0ZXIucmVnaXN0ZXIob3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrUmVnaXN0ZXJPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGNyZWF0ZVJlZ2lzdGVyVXJsIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTG9naW5VcmwoeyAuLi5vcHRpb25zLCBhY3Rpb246ICdyZWdpc3RlcicgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrQWNjb3VudE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlQWNjb3VudFVybCAob3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2dldFJlYWxtVXJsKClcblxuICAgIGlmICghdXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgYWNjb3VudCBVUkwsIG1ha2Ugc3VyZSB0aGUgYWRhcHRlciBpcyBub3QgY29uZmlndXJlZCB1c2luZyBhIGdlbmVyaWMgT0lEQyBwcm92aWRlci4nKVxuICAgIH1cblxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgICAgWydyZWZlcnJlcicsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jbGllbnRJZCldLFxuICAgICAgWydyZWZlcnJlcl91cmknLCB0aGlzLiNhZGFwdGVyLnJlZGlyZWN0VXJpKG9wdGlvbnMpXVxuICAgIF0pXG5cbiAgICByZXR1cm4gYCR7dXJsfS9hY2NvdW50PyR7cGFyYW1zLnRvU3RyaW5nKCl9YFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYWNjb3VudE1hbmFnZW1lbnQgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZGFwdGVyLmFjY291bnRNYW5hZ2VtZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1JlYWxtUm9sZSAocm9sZSkge1xuICAgIGNvbnN0IGFjY2VzcyA9IHRoaXMucmVhbG1BY2Nlc3NcbiAgICByZXR1cm4gISFhY2Nlc3MgJiYgYWNjZXNzLnJvbGVzLmluZGV4T2Yocm9sZSkgPj0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzb3VyY2VdXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzUmVzb3VyY2VSb2xlIChyb2xlLCByZXNvdXJjZSkge1xuICAgIGlmICghdGhpcy5yZXNvdXJjZUFjY2Vzcykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgYWNjZXNzID0gdGhpcy5yZXNvdXJjZUFjY2Vzc1tyZXNvdXJjZSB8fCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMuY2xpZW50SWQpXVxuICAgIHJldHVybiAhIWFjY2VzcyAmJiBhY2Nlc3Mucm9sZXMuaW5kZXhPZihyb2xlKSA+PSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5Y2xvYWtQcm9maWxlPn1cbiAgICovXG4gIGFzeW5jIGxvYWRVc2VyUHJvZmlsZSAoKSB7XG4gICAgY29uc3QgcmVhbG1VcmwgPSB0aGlzLiNnZXRSZWFsbVVybCgpXG5cbiAgICBpZiAoIXJlYWxtVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2FkIHVzZXIgcHJvZmlsZSwgbWFrZSBzdXJlIHRoZSBhZGFwdGVyIGlzIG5vdCBjb25maWd1cmVkIHVzaW5nIGEgZ2VuZXJpYyBPSURDIHByb3ZpZGVyLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gYCR7cmVhbG1Vcmx9L2FjY291bnRgXG4gICAgLyoqIEB0eXBlIHtLZXljbG9ha1Byb2ZpbGV9ICovXG4gICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGZldGNoSlNPTih1cmwsIHtcbiAgICAgIGhlYWRlcnM6IFtidWlsZEF1dGhvcml6YXRpb25IZWFkZXIodGhpcy50b2tlbildXG4gICAgfSlcblxuICAgIHJldHVybiAodGhpcy5wcm9maWxlID0gcHJvZmlsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7fT59XG4gICAqL1xuICBhc3luYyBsb2FkVXNlckluZm8gKCkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnRzLnVzZXJpbmZvKClcbiAgICAvKiogQHR5cGUge3t9fSAqL1xuICAgIGNvbnN0IHVzZXJJbmZvID0gYXdhaXQgZmV0Y2hKU09OKHVybCwge1xuICAgICAgaGVhZGVyczogW2J1aWxkQXV0aG9yaXphdGlvbkhlYWRlcih0aGlzLnRva2VuKV1cbiAgICB9KVxuXG4gICAgcmV0dXJuICh0aGlzLnVzZXJJbmZvID0gdXNlckluZm8pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5WYWxpZGl0eV1cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1Rva2VuRXhwaXJlZCAobWluVmFsaWRpdHkpIHtcbiAgICBpZiAoIXRoaXMudG9rZW5QYXJzZWQgfHwgKCF0aGlzLnJlZnJlc2hUb2tlbiAmJiB0aGlzLmZsb3cgIT09ICdpbXBsaWNpdCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lU2tldyA9PSBudWxsKSB7XG4gICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIFVuYWJsZSB0byBkZXRlcm1pbmUgaWYgdG9rZW4gaXMgZXhwaXJlZCBhcyB0aW1lc2tldyBpcyBub3Qgc2V0JylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRva2VuUGFyc2VkLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGxldCBleHBpcmVzSW4gPSB0aGlzLnRva2VuUGFyc2VkLmV4cCAtIE1hdGguY2VpbChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgdGhpcy50aW1lU2tld1xuICAgIGlmIChtaW5WYWxpZGl0eSkge1xuICAgICAgaWYgKGlzTmFOKG1pblZhbGlkaXR5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWluVmFsaWRpdHknKVxuICAgICAgfVxuICAgICAgZXhwaXJlc0luIC09IG1pblZhbGlkaXR5XG4gICAgfVxuICAgIHJldHVybiBleHBpcmVzSW4gPCAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblZhbGlkaXR5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVG9rZW4gKG1pblZhbGlkaXR5KSB7XG4gICAgaWYgKCF0aGlzLnJlZnJlc2hUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdXBkYXRlIHRva2VuLCBubyByZWZyZXNoIHRva2VuIGF2YWlsYWJsZS4nKVxuICAgIH1cblxuICAgIG1pblZhbGlkaXR5ID0gbWluVmFsaWRpdHkgfHwgNVxuXG4gICAgaWYgKHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSkge1xuICAgICAgYXdhaXQgdGhpcy4jY2hlY2tMb2dpbklmcmFtZSgpXG4gICAgfVxuXG4gICAgbGV0IHJlZnJlc2hUb2tlbiA9IGZhbHNlXG5cbiAgICBpZiAobWluVmFsaWRpdHkgPT09IC0xKSB7XG4gICAgICByZWZyZXNoVG9rZW4gPSB0cnVlXG4gICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIFJlZnJlc2hpbmcgdG9rZW46IGZvcmNlZCByZWZyZXNoJylcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnRva2VuUGFyc2VkIHx8IHRoaXMuaXNUb2tlbkV4cGlyZWQobWluVmFsaWRpdHkpKSB7XG4gICAgICByZWZyZXNoVG9rZW4gPSB0cnVlXG4gICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIFJlZnJlc2hpbmcgdG9rZW46IHRva2VuIGV4cGlyZWQnKVxuICAgIH1cblxuICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1Byb21pc2VXaXRoUmVzb2x2ZXJzPGJvb2xlYW4+fSAqL1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKVxuXG4gICAgdGhpcy4jcmVmcmVzaFF1ZXVlLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSlcblxuICAgIGlmICh0aGlzLiNyZWZyZXNoUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50cy50b2tlbigpXG4gICAgICBsZXQgdGltZUxvY2FsID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFJlZnJlc2hUb2tlbih1cmwsIHRoaXMucmVmcmVzaFRva2VuLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMuY2xpZW50SWQpKVxuICAgICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIFRva2VuIHJlZnJlc2hlZCcpXG5cbiAgICAgICAgdGltZUxvY2FsID0gKHRpbWVMb2NhbCArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAvIDJcblxuICAgICAgICB0aGlzLiNzZXRUb2tlbihyZXNwb25zZS5hY2Nlc3NfdG9rZW4sIHJlc3BvbnNlLnJlZnJlc2hfdG9rZW4sIHJlc3BvbnNlLmlkX3Rva2VuLCB0aW1lTG9jYWwpXG5cbiAgICAgICAgdGhpcy5vbkF1dGhSZWZyZXNoU3VjY2Vzcz8uKClcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuI3JlZnJlc2hRdWV1ZS5wb3AoKTsgcCAhPSBudWxsOyBwID0gdGhpcy4jcmVmcmVzaFF1ZXVlLnBvcCgpKSB7XG4gICAgICAgICAgcC5yZXNvbHZlKHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuI2xvZ1dhcm4oJ1tLRVlDTE9BS10gRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW4nKVxuXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvciAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQXV0aFJlZnJlc2hFcnJvcj8uKClcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuI3JlZnJlc2hRdWV1ZS5wb3AoKTsgcCAhPSBudWxsOyBwID0gdGhpcy4jcmVmcmVzaFF1ZXVlLnBvcCgpKSB7XG4gICAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZVxuICB9XG5cbiAgY2xlYXJUb2tlbiAoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgIHRoaXMuI3NldFRva2VuKClcbiAgICAgIHRoaXMub25BdXRoTG9nb3V0Py4oKVxuICAgICAgaWYgKHRoaXMubG9naW5SZXF1aXJlZCkge1xuICAgICAgICB0aGlzLmxvZ2luKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0b2tlbl1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZWZyZXNoVG9rZW5dXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRUb2tlbl1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lTG9jYWxdXG4gICAqL1xuICAjc2V0VG9rZW4gKHRva2VuLCByZWZyZXNoVG9rZW4sIGlkVG9rZW4sIHRpbWVMb2NhbCkge1xuICAgIGlmICh0aGlzLnRva2VuVGltZW91dEhhbmRsZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9rZW5UaW1lb3V0SGFuZGxlKVxuICAgICAgdGhpcy50b2tlblRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAocmVmcmVzaFRva2VuKSB7XG4gICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlblxuICAgICAgdGhpcy5yZWZyZXNoVG9rZW5QYXJzZWQgPSBkZWNvZGVUb2tlbihyZWZyZXNoVG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZnJlc2hUb2tlblxuICAgICAgZGVsZXRlIHRoaXMucmVmcmVzaFRva2VuUGFyc2VkXG4gICAgfVxuXG4gICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgIHRoaXMuaWRUb2tlbiA9IGlkVG9rZW5cbiAgICAgIHRoaXMuaWRUb2tlblBhcnNlZCA9IGRlY29kZVRva2VuKGlkVG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkVG9rZW5cbiAgICAgIGRlbGV0ZSB0aGlzLmlkVG9rZW5QYXJzZWRcbiAgICB9XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgdGhpcy50b2tlblBhcnNlZCA9IGRlY29kZVRva2VuKHRva2VuKVxuICAgICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLnRva2VuUGFyc2VkLnNpZFxuICAgICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5zdWJqZWN0ID0gdGhpcy50b2tlblBhcnNlZC5zdWJcbiAgICAgIHRoaXMucmVhbG1BY2Nlc3MgPSB0aGlzLnRva2VuUGFyc2VkLnJlYWxtX2FjY2Vzc1xuICAgICAgdGhpcy5yZXNvdXJjZUFjY2VzcyA9IHRoaXMudG9rZW5QYXJzZWQucmVzb3VyY2VfYWNjZXNzXG5cbiAgICAgIGlmICh0aW1lTG9jYWwpIHtcbiAgICAgICAgdGhpcy50aW1lU2tldyA9IE1hdGguZmxvb3IodGltZUxvY2FsIC8gMTAwMCkgLSB0aGlzLnRva2VuUGFyc2VkLmlhdFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50aW1lU2tldyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIEVzdGltYXRlZCB0aW1lIGRpZmZlcmVuY2UgYmV0d2VlbiBicm93c2VyIGFuZCBzZXJ2ZXIgaXMgJyArIHRoaXMudGltZVNrZXcgKyAnIHNlY29uZHMnKVxuXG4gICAgICAgIGlmICh0aGlzLm9uVG9rZW5FeHBpcmVkKSB7XG4gICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gKHRoaXMudG9rZW5QYXJzZWQuZXhwIC0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyB0aGlzLnRpbWVTa2V3KSAqIDEwMDBcbiAgICAgICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIFRva2VuIGV4cGlyZXMgaW4gJyArIE1hdGgucm91bmQoZXhwaXJlc0luIC8gMTAwMCkgKyAnIHMnKVxuICAgICAgICAgIGlmIChleHBpcmVzSW4gPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5vblRva2VuRXhwaXJlZCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5UaW1lb3V0SGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5vblRva2VuRXhwaXJlZCwgZXhwaXJlc0luKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy50b2tlblxuICAgICAgZGVsZXRlIHRoaXMudG9rZW5QYXJzZWRcbiAgICAgIGRlbGV0ZSB0aGlzLnN1YmplY3RcbiAgICAgIGRlbGV0ZSB0aGlzLnJlYWxtQWNjZXNzXG4gICAgICBkZWxldGUgdGhpcy5yZXNvdXJjZUFjY2Vzc1xuXG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nPX1cbiAgICovXG4gICNnZXRSZWFsbVVybCAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmF1dGhTZXJ2ZXJVcmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gYCR7c3RyaXBUcmFpbGluZ1NsYXNoKHRoaXMuYXV0aFNlcnZlclVybCl9L3JlYWxtcy8ke2VuY29kZVVSSUNvbXBvbmVudCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMucmVhbG0pKX1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMgeyhtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWR9XG4gICAqL1xuICAjY3JlYXRlTG9nZ2VyIChmbikge1xuICAgIHJldHVybiAobWVzc2FnZSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlTG9nZ2luZykge1xuICAgICAgICBmbi5jYWxsKGNvbnNvbGUsIG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVVVJRCAoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY3J5cHRvLnJhbmRvbVVVSUQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgQ3J5cHRvIEFQSSBpcyBub3QgYXZhaWxhYmxlLicpXG4gIH1cblxuICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWNyfSByZXF1ZXN0ZWRBY3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ2xhaW1zUGFyYW1ldGVyIChyZXF1ZXN0ZWRBY3IpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICBpZF90b2tlbjoge1xuICAgICAgYWNyOiByZXF1ZXN0ZWRBY3JcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlVmVyaWZpZXIgKGxlbikge1xuICByZXR1cm4gZ2VuZXJhdGVSYW5kb21TdHJpbmcobGVuLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2NlTWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVZlcmlmaWVyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBrY2VDaGFsbGVuZ2UgKHBrY2VNZXRob2QsIGNvZGVWZXJpZmllcikge1xuICBpZiAocGtjZU1ldGhvZCAhPT0gJ1MyNTYnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgJ3BrY2VNZXRob2QnLCBleHBlY3RlZCAnUzI1NicgYnV0IGdvdCAnJHtwa2NlTWV0aG9kfScuYClcbiAgfVxuXG4gIC8vIGhhc2ggY29kZVZlcmlmaWVyLCB0aGVuIGVuY29kZSBhcyB1cmwtc2FmZSBiYXNlNjQgd2l0aG91dCBwYWRkaW5nXG4gIGNvbnN0IGhhc2hCeXRlcyA9IG5ldyBVaW50OEFycmF5KGF3YWl0IHNoYTI1NkRpZ2VzdChjb2RlVmVyaWZpZXIpKVxuICBjb25zdCBlbmNvZGVkSGFzaCA9IGJ5dGVzVG9CYXNlNjQoaGFzaEJ5dGVzKVxuICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxuICAgIC5yZXBsYWNlKC89L2csICcnKVxuXG4gIHJldHVybiBlbmNvZGVkSGFzaFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdHJpbmcgKGxlbiwgYWxwaGFiZXQpIHtcbiAgY29uc3QgcmFuZG9tRGF0YSA9IGdlbmVyYXRlUmFuZG9tRGF0YShsZW4pXG4gIGNvbnN0IGNoYXJzID0gbmV3IEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNoYXJzW2ldID0gYWxwaGFiZXQuY2hhckNvZGVBdChyYW5kb21EYXRhW2ldICUgYWxwaGFiZXQubGVuZ3RoKVxuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNoYXJzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5PEFycmF5QnVmZmVyPn1cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21EYXRhIChsZW4pIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViIENyeXB0byBBUEkgaXMgbm90IGF2YWlsYWJsZS4nKVxuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkobGVuKSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBleHRlbmQgZXhpc3RpbmcgbmF0aXZlIFByb21pc2Ugd2l0aCB0aW1lb3V0XG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvck1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fVxuICovXG5mdW5jdGlvbiBhcHBseVRpbWVvdXRUb1Byb21pc2UgKHByb21pc2UsIHRpbWVvdXQsIGVycm9yTWVzc2FnZSkge1xuICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgbGV0IHRpbWVvdXRIYW5kbGVcbiAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdGltZW91dEhhbmRsZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3JNZXNzYWdlIHx8ICdQcm9taXNlIGlzIG5vdCBzZXR0bGVkIHdpdGhpbiB0aW1lb3V0IG9mICcgKyB0aW1lb3V0ICsgJ21zJykpXG4gICAgfSwgdGltZW91dClcbiAgfSlcblxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKVxuICB9KVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHtDYWxsYmFja1N0b3JhZ2V9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrU3RvcmFnZSAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFN0b3JhZ2UoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IENvb2tpZVN0b3JhZ2UoKVxuICB9XG59XG5cbmNvbnN0IFNUT1JBR0VfS0VZX1BSRUZJWCA9ICdrYy1jYWxsYmFjay0nXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FsbGJhY2tTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbm9uY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZWRpcmVjdFVyaVxuICogQHByb3BlcnR5IHtLZXljbG9ha0xvZ2luT3B0aW9uc30gW2xvZ2luT3B0aW9uc11cbiAqIEBwcm9wZXJ0eSB7S2V5Y2xvYWtMb2dpbk9wdGlvbnNbJ3Byb21wdCddfSBbcHJvbXB0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwa2NlQ29kZVZlcmlmaWVyXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FsbGJhY2tTdG9yYWdlXG4gKiBAcHJvcGVydHkgeyhzdGF0ZT86IHN0cmluZykgPT4gQ2FsbGJhY2tTdGF0ZSB8IG51bGx9IGdldFxuICogQHByb3BlcnR5IHsoc3RhdGU6IENhbGxiYWNrU3RhdGUpID0+IHZvaWR9IGFkZFxuICovXG5cbi8qKlxuICogQGltcGxlbWVudHMge0NhbGxiYWNrU3RvcmFnZX1cbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2tjLXRlc3QnLCAndGVzdCcpXG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgna2MtdGVzdCcpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV1cbiAgICogQHJldHVybnMge0NhbGxiYWNrU3RhdGUgfCBudWxsfVxuICAgKi9cbiAgZ2V0IChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy4jY2xlYXJJbnZhbGlkVmFsdWVzKClcblxuICAgIGNvbnN0IGtleSA9IFNUT1JBR0VfS0VZX1BSRUZJWCArIHN0YXRlXG4gICAgY29uc3QgdmFsdWUgPSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbGxiYWNrU3RhdGV9IHN0YXRlXG4gICAqL1xuICBhZGQgKHN0YXRlKSB7XG4gICAgdGhpcy4jY2xlYXJJbnZhbGlkVmFsdWVzKClcblxuICAgIGNvbnN0IGtleSA9IFNUT1JBR0VfS0VZX1BSRUZJWCArIHN0YXRlLnN0YXRlXG4gICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC8vIFNldCB0aGUgZXhwaXJ5IHRpbWUgdG8gMSBob3VyIGZyb20gbm93LlxuICAgICAgZXhwaXJlczogRGF0ZS5ub3coKSArICg2MCAqIDYwICogMTAwMClcbiAgICB9KVxuXG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhlIHN0b3JhZ2UgaXMgZnVsbCwgY2xlYXIgYWxsIGtub3duIHZhbHVlcyBhbmQgdHJ5IGFnYWluLlxuICAgICAgdGhpcy4jY2xlYXJBbGxWYWx1ZXMoKVxuICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCB2YWx1ZXMgZnJvbSBsb2NhbCBzdG9yYWdlIHRoYXQgYXJlIG5vIGxvbmdlciB2YWxpZC5cbiAgICovXG4gICNjbGVhckludmFsaWRWYWx1ZXMgKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jZ2V0U3RvcmVkRW50cmllcygpKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBleHBpcnkgdGltZSBmcm9tIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGV4cGlyeSA9IHRoaXMuI3BhcnNlRXhwaXJ5KHZhbHVlKVxuXG4gICAgICAvLyBEaXNjYXJkIHRoZSB2YWx1ZSBpZiBpdCBpcyBtYWxmb3JtZWQgb3IgZXhwaXJlZC5cbiAgICAgIGlmIChleHBpcnkgPT09IG51bGwgfHwgZXhwaXJ5IDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwga25vd24gdmFsdWVzIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgICovXG4gICNjbGVhckFsbFZhbHVlcyAoKSB7XG4gICAgZm9yIChjb25zdCBba2V5XSBvZiB0aGlzLiNnZXRTdG9yZWRFbnRyaWVzKCkpIHtcbiAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCBlbnRyaWVzIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlIHRoYXQgYXJlIGtub3duIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBjbGFzcy5cbiAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ11bXX0gQW4gYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgI2dldFN0b3JlZEVudHJpZXMgKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSkuZmlsdGVyKChba2V5XSkgPT4ga2V5LnN0YXJ0c1dpdGgoU1RPUkFHRV9LRVlfUFJFRklYKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGV4cGlyeSB0aW1lIGZyb20gYSB2YWx1ZSBzdG9yZWQgaW4gbG9jYWwgc3RvcmFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfSBUaGUgZXhwaXJ5IHRpbWUgaW4gbWlsbGlzZWNvbmRzLCBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG1hbGZvcm1lZC5cbiAgICovXG4gICNwYXJzZUV4cGlyeSAodmFsdWUpIHtcbiAgICBsZXQgcGFyc2VkVmFsdWVcblxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIHZhbHVlIGFzIEpTT04uXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIGV4dHJhY3QgdGhlICdleHBpcmVzJyBwcm9wZXJ0eS5cbiAgICBpZiAoaXNPYmplY3QocGFyc2VkVmFsdWUpICYmICdleHBpcmVzJyBpbiBwYXJzZWRWYWx1ZSAmJiB0eXBlb2YgcGFyc2VkVmFsdWUuZXhwaXJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwYXJzZWRWYWx1ZS5leHBpcmVzXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtDYWxsYmFja1N0b3JhZ2V9XG4gKi9cbmNsYXNzIENvb2tpZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0ZV1cbiAgICogQHJldHVybnMge0NhbGxiYWNrU3RhdGUgfCBudWxsfVxuICAgKi9cbiAgZ2V0IChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNnZXRDb29raWUoU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGUpXG4gICAgdGhpcy4jc2V0Q29va2llKFNUT1JBR0VfS0VZX1BSRUZJWCArIHN0YXRlLCAnJywgdGhpcy4jY29va2llRXhwaXJhdGlvbigtMTAwKSlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWxsYmFja1N0YXRlfSBzdGF0ZVxuICAgKi9cbiAgYWRkIChzdGF0ZSkge1xuICAgIHRoaXMuI3NldENvb2tpZShTVE9SQUdFX0tFWV9QUkVGSVggKyBzdGF0ZS5zdGF0ZSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpLCB0aGlzLiNjb29raWVFeHBpcmF0aW9uKDYwKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICAjZ2V0Q29va2llIChrZXkpIHtcbiAgICBjb25zdCBuYW1lID0ga2V5ICsgJz0nXG4gICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gY2FbaV1cbiAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgIGMgPSBjLnN1YnN0cmluZygxKVxuICAgICAgfVxuICAgICAgaWYgKGMuaW5kZXhPZihuYW1lKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZS5sZW5ndGgsIGMubGVuZ3RoKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0RhdGV9IGV4cGlyYXRpb25EYXRlXG4gICAqL1xuICAjc2V0Q29va2llIChrZXksIHZhbHVlLCBleHBpcmF0aW9uRGF0ZSkge1xuICAgIGNvbnN0IGNvb2tpZSA9IGtleSArICc9JyArIHZhbHVlICsgJzsgJyArXG4gICAgICAgICAgICAnZXhwaXJlcz0nICsgZXhwaXJhdGlvbkRhdGUudG9VVENTdHJpbmcoKSArICc7ICdcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWludXRlc1xuICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICovXG4gICNjb29raWVFeHBpcmF0aW9uIChtaW51dGVzKSB7XG4gICAgY29uc3QgZXhwID0gbmV3IERhdGUoKVxuICAgIGV4cC5zZXRUaW1lKGV4cC5nZXRUaW1lKCkgKyAobWludXRlcyAqIDYwICogMTAwMCkpXG4gICAgcmV0dXJuIGV4cFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5PEFycmF5QnVmZmVyPn0gYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9HbG9zc2FyeS9CYXNlNjQjdGhlX3VuaWNvZGVfcHJvYmxlbVxuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0IChieXRlcykge1xuICBjb25zdCBiaW5TdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5ieXRlcylcbiAgcmV0dXJuIGJ0b2EoYmluU3RyaW5nKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGlnZXN0I2Jhc2ljX2V4YW1wbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2hhMjU2RGlnZXN0IChtZXNzYWdlKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUobWVzc2FnZSlcblxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNyeXB0by5zdWJ0bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgQ3J5cHRvIEFQSSBpcyBub3QgYXZhaWxhYmxlLicpXG4gIH1cblxuICByZXR1cm4gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBkYXRhKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHJldHVybnMge0tleWNsb2FrVG9rZW5QYXJzZWR9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRva2VuICh0b2tlbikge1xuICBjb25zdCBbLCBwYXlsb2FkXSA9IHRva2VuLnNwbGl0KCcuJylcblxuICBpZiAodHlwZW9mIHBheWxvYWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjb2RlIHRva2VuLCBwYXlsb2FkIG5vdCBmb3VuZC4nKVxuICB9XG5cbiAgbGV0IGRlY29kZWRcblxuICB0cnkge1xuICAgIGRlY29kZWQgPSBiYXNlNjRVcmxEZWNvZGUocGF5bG9hZClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgdG9rZW4sIHBheWxvYWQgaXMgbm90IGEgdmFsaWQgQmFzZTY0VVJMIHZhbHVlLicsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjb2RlIHRva2VuLCBwYXlsb2FkIGlzIG5vdCBhIHZhbGlkIEpTT04gdmFsdWUuJywgeyBjYXVzZTogZXJyb3IgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICovXG5mdW5jdGlvbiBiYXNlNjRVcmxEZWNvZGUgKGlucHV0KSB7XG4gIGxldCBvdXRwdXQgPSBpbnB1dFxuICAgIC5yZXBsYWNlQWxsKCctJywgJysnKVxuICAgIC5yZXBsYWNlQWxsKCdfJywgJy8nKVxuXG4gIHN3aXRjaCAob3V0cHV0Lmxlbmd0aCAlIDQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIG91dHB1dCArPSAnPT0nXG4gICAgICBicmVha1xuICAgIGNhc2UgMzpcbiAgICAgIG91dHB1dCArPSAnPSdcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgaXMgbm90IG9mIHRoZSBjb3JyZWN0IGxlbmd0aC4nKVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYjY0RGVjb2RlVW5pY29kZShvdXRwdXQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGF0b2Iob3V0cHV0KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGI2NERlY29kZVVuaWNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoYXRvYihpbnB1dCkucmVwbGFjZSgvKC4pL2csIChtLCBwKSA9PiB7XG4gICAgbGV0IGNvZGUgPSBwLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcblxuICAgIGlmIChjb2RlLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlXG4gICAgfVxuXG4gICAgcmV0dXJuICclJyArIGNvZGVcbiAgfSkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGlucHV0IGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBvcGVyYXRlZCBvbi5cbiAqIEBwYXJhbSB7dW5rbm93bn0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0ICE9PSBudWxsXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSnNvbkNvbmZpZyBUaGUgSlNPTiB2ZXJzaW9uIG9mIHRoZSBhZGFwdGVyIGNvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXV0aC1zZXJ2ZXItdXJsIFRoZSBVUkwgb2YgdGhlIGF1dGhlbnRpY2F0aW9uIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZWFsbSBUaGUgbmFtZSBvZiB0aGUgcmVhbG0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb3VyY2UgVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlLCB1c3VhbGx5IHRoZSBjbGllbnQgSUQuXG4gKi9cblxuLyoqXG4gKiBGZXRjaCB0aGUgYWRhcHRlciBjb25maWd1cmF0aW9uIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtQcm9taXNlPEpzb25Db25maWc+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEpzb25Db25maWcgKHVybCkge1xuICByZXR1cm4gYXdhaXQgZmV0Y2hKU09OKHVybClcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgT3BlbklEIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge1Byb21pc2U8T3BlbklkUHJvdmlkZXJNZXRhZGF0YT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoT3BlbklkQ29uZmlnICh1cmwpIHtcbiAgcmV0dXJuIGF3YWl0IGZldGNoSlNPTih1cmwpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQWNjZXNzVG9rZW5SZXNwb25zZSBUaGUgc3VjY2Vzc2Z1bCB0b2tlbiByZXNwb25zZSBmcm9tIHRoZSBhdXRob3JpemF0aW9uIHNlcnZlciwgYmFzZWQgb24gdGhlIHtAbGluayBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY3NDkjc2VjdGlvbi01LjEgT0F1dGggMi4wIEF1dGhvcml6YXRpb24gRnJhbWV3b3JrIHNwZWNpZmljYXRpb259LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFjY2Vzc190b2tlbiBUaGUgYWNjZXNzIHRva2VuIGlzc3VlZCBieSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG9rZW5fdHlwZSBUaGUgdHlwZSBvZiB0aGUgdG9rZW4gaXNzdWVkIGJ5IHRoZSBhdXRob3JpemF0aW9uIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZXhwaXJlc19pbl0gVGhlIGxpZmV0aW1lIGluIHNlY29uZHMgb2YgdGhlIGFjY2VzcyB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVmcmVzaF90b2tlbl0gVGhlIHJlZnJlc2ggdG9rZW4gaXNzdWVkIGJ5IHRoZSBhdXRob3JpemF0aW9uIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRfdG9rZW5dIFRoZSBJRCB0b2tlbiBpc3N1ZWQgYnkgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyLCBpZiByZXF1ZXN0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Njb3BlXSBUaGUgc2NvcGUgb2YgdGhlIGFjY2VzcyB0b2tlbi5cbiAqL1xuXG4vKipcbiAqIEZldGNoIHRoZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGllbnRJZFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZGlyZWN0VXJpXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BrY2VDb2RlVmVyaWZpZXJdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBY2Nlc3NUb2tlblJlc3BvbnNlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBY2Nlc3NUb2tlbiAodXJsLCBjb2RlLCBjbGllbnRJZCwgcmVkaXJlY3RVcmksIHBrY2VDb2RlVmVyaWZpZXIpIHtcbiAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgIFsnY29kZScsIGNvZGVdLFxuICAgIFsnZ3JhbnRfdHlwZScsICdhdXRob3JpemF0aW9uX2NvZGUnXSxcbiAgICBbJ2NsaWVudF9pZCcsIGNsaWVudElkXSxcbiAgICBbJ3JlZGlyZWN0X3VyaScsIHN0cmlwSGFzaChyZWRpcmVjdFVyaSldXG4gIF0pXG5cbiAgaWYgKHBrY2VDb2RlVmVyaWZpZXIpIHtcbiAgICBib2R5LmFwcGVuZCgnY29kZV92ZXJpZmllcicsIHBrY2VDb2RlVmVyaWZpZXIpXG4gIH1cblxuICByZXR1cm4gYXdhaXQgZmV0Y2hKU09OKHVybCwge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgYm9keVxuICB9KVxufVxuXG4vKipcbiAqIEZldGNoIHRoZSByZWZyZXNoIHRva2VuIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWZyZXNoVG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGllbnRJZFxuICogQHJldHVybnMge1Byb21pc2U8QWNjZXNzVG9rZW5SZXNwb25zZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVmcmVzaFRva2VuICh1cmwsIHJlZnJlc2hUb2tlbiwgY2xpZW50SWQpIHtcbiAgY29uc3QgYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgIFsnZ3JhbnRfdHlwZScsICdyZWZyZXNoX3Rva2VuJ10sXG4gICAgWydyZWZyZXNoX3Rva2VuJywgcmVmcmVzaFRva2VuXSxcbiAgICBbJ2NsaWVudF9pZCcsIGNsaWVudElkXVxuICBdKVxuXG4gIHJldHVybiBhd2FpdCBmZXRjaEpTT04odXJsLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBib2R5XG4gIH0pXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPXVua25vd25dXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1JlcXVlc3RJbml0fSBpbml0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hKU09OICh1cmwsIGluaXQgPSB7fSkge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKVxuICBoZWFkZXJzLnNldCgnQWNjZXB0JywgQ09OVEVOVF9UWVBFX0pTT04pXG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhFcnJvckhhbmRsaW5nKHVybCwge1xuICAgIC4uLmluaXQsXG4gICAgaGVhZGVyc1xuICB9KVxuXG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1JlcXVlc3RJbml0fSBbaW5pdF1cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyAodXJsLCBpbml0KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBpbml0KVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgTmV0d29ya0Vycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYW4gaW52YWxpZCBzdGF0dXMuJywgeyByZXNwb25zZSB9KVxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFt0b2tlbl1cbiAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICovXG5mdW5jdGlvbiBidWlsZEF1dGhvcml6YXRpb25IZWFkZXIgKHRva2VuKSB7XG4gIGlmICghdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBidWlsZCBhdXRob3JpemF0aW9uIGhlYWRlciwgdG9rZW4gaXMgbm90IHNldCwgbWFrZSBzdXJlIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQuJylcbiAgfVxuXG4gIHJldHVybiBbJ0F1dGhvcml6YXRpb24nLCBgYmVhcmVyICR7dG9rZW59YF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2ggKHVybCkge1xuICByZXR1cm4gdXJsLmVuZHNXaXRoKCcvJykgPyB1cmwuc2xpY2UoMCwgLTEpIDogdXJsXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaXBIYXNoICh1cmwpIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpXG4gIHBhcnNlZFVybC5oYXNoID0gJydcbiAgcmV0dXJuIHBhcnNlZFVybC50b1N0cmluZygpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTmV0d29ya0Vycm9yT3B0aW9uc1Byb3BlcnRpZXNcbiAqIEBwcm9wZXJ0eSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gKiBAdHlwZWRlZiB7RXJyb3JPcHRpb25zICYgTmV0d29ya0Vycm9yT3B0aW9uc1Byb3BlcnRpZXN9IE5ldHdvcmtFcnJvck9wdGlvbnNcbiAqL1xuXG5leHBvcnQgY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQHR5cGUge1Jlc3BvbnNlfSAqL1xuICByZXNwb25zZVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge05ldHdvcmtFcnJvck9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucylcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3Qgd2FpdEZvclRpbWVvdXQgPSAoZGVsYXkpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/keycloak-js/lib/keycloak.js\n");

/***/ })

};
;