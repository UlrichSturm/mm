"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/keycloak-js";
exports.ids = ["vendor-chunks/keycloak-js"];
exports.modules = {

/***/ "(ssr)/../../node_modules/keycloak-js/lib/keycloak.js":
/*!******************************************************!*\
  !*** ../../node_modules/keycloak-js/lib/keycloak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   \"default\": () => (/* binding */ Keycloak)\n/* harmony export */ });\n// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json'\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\n\nclass Keycloak {\n  /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n  #refreshQueue = []\n  /** @type {KeycloakAdapter} */\n  #adapter\n  /** @type {boolean} */\n  #useNonce = true\n  /** @type {CallbackStorage} */\n  #callbackStorage\n  #logInfo = this.#createLogger(console.info)\n  #logWarn = this.#createLogger(console.warn)\n  /** @type {LoginIframe} */\n  #loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  }\n\n  /** @type {KeycloakConfig} config */\n  #config\n  didInitialize = false\n  authenticated = false\n  loginRequired = false\n  /** @type {KeycloakResponseMode} */\n  responseMode = 'fragment'\n  /** @type {KeycloakResponseType} */\n  responseType = 'code'\n  /** @type {KeycloakFlow} */\n  flow = 'standard'\n  /** @type {number?} */\n  timeSkew = null\n  /** @type {string=} */\n  redirectUri\n  /** @type {string=} */\n  silentCheckSsoRedirectUri\n  /** @type {boolean} */\n  silentCheckSsoFallback = true\n  /** @type {KeycloakPkceMethod} */\n  pkceMethod = 'S256'\n  enableLogging = false\n  /** @type {'GET' | 'POST'} */\n  logoutMethod = 'GET'\n  /** @type {string=} */\n  scope\n  messageReceiveTimeout = 10000\n  /** @type {string=} */\n  idToken\n  /** @type {KeycloakTokenParsed=} */\n  idTokenParsed\n  /** @type {string=} */\n  token\n  /** @type {KeycloakTokenParsed=} */\n  tokenParsed\n  /** @type {string=} */\n  refreshToken\n  /** @type {KeycloakTokenParsed=} */\n  refreshTokenParsed\n  /** @type {string=} */\n  clientId\n  /** @type {string=} */\n  sessionId\n  /** @type {string=} */\n  subject\n  /** @type {string=} */\n  authServerUrl\n  /** @type {string=} */\n  realm\n  /** @type {KeycloakRoles=} */\n  realmAccess\n  /** @type {KeycloakResourceAccess=} */\n  resourceAccess\n  /** @type {KeycloakProfile=} */\n  profile\n  /** @type {{}=} */\n  userInfo\n  /** @type {Endpoints} */\n  endpoints\n  /** @type {number=} */\n  tokenTimeoutHandle\n  /** @type {() => void=} */\n  onAuthSuccess\n  /** @type {(errorData?: KeycloakError) => void=} */\n  onAuthError\n  /** @type {() => void=} */\n  onAuthRefreshSuccess\n  /** @type {() => void=} */\n  onAuthRefreshError\n  /** @type {() => void=} */\n  onTokenExpired\n  /** @type {() => void=} */\n  onAuthLogout\n  /** @type {(authenticated: boolean) => void=} */\n  onReady\n  /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n  onActionUpdate\n\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor (config) {\n    if (typeof config !== 'string' && !isObject(config)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\")\n    }\n\n    if (isObject(config)) {\n      const requiredProperties = 'oidcProvider' in config\n        ? ['clientId']\n        : ['url', 'realm', 'clientId']\n\n      for (const property of requiredProperties) {\n        if (!(property in config)) {\n          throw new Error(`The configuration object is missing the required '${property}' property.`)\n        }\n      }\n    }\n\n    if (!globalThis.isSecureContext) {\n      this.#logWarn(\n        \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n                'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' +\n                'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts'\n      )\n    }\n\n    this.#config = config\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  async init (initOptions = {}) {\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\")\n    }\n\n    this.didInitialize = true\n    this.#callbackStorage = createCallbackStorage()\n\n    const adapters = ['default', 'cordova', 'cordova-native']\n\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      this.#adapter = this.#loadAdapter(initOptions.adapter)\n    } else if (typeof initOptions.adapter === 'object') {\n      this.#adapter = initOptions.adapter\n    } else if ('Cordova' in window || 'cordova' in window) {\n      this.#adapter = this.#loadAdapter('cordova')\n    } else {\n      this.#adapter = this.#loadAdapter('default')\n    }\n\n    if (typeof initOptions.useNonce !== 'undefined') {\n      this.#useNonce = initOptions.useNonce\n    }\n\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      this.#loginIframe.enable = initOptions.checkLoginIframe\n    }\n\n    if (initOptions.checkLoginIframeInterval) {\n      this.#loginIframe.interval = initOptions.checkLoginIframeInterval\n    }\n\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true\n    }\n\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode\n      } else {\n        throw new Error('Invalid value for responseMode')\n      }\n    }\n\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code'\n          break\n        case 'implicit':\n          this.responseType = 'id_token token'\n          break\n        case 'hybrid':\n          this.responseType = 'code id_token token'\n          break\n        default:\n          throw new Error('Invalid value for flow')\n      }\n      this.flow = initOptions.flow\n    }\n\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew\n    }\n\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri\n    }\n\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri\n    }\n\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback\n    }\n\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`)\n      }\n\n      this.pkceMethod = initOptions.pkceMethod\n    }\n\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging\n    }\n\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST'\n    }\n\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope\n    }\n\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout\n    }\n\n    await this.#loadConfig()\n    await this.#check3pCookiesSupported()\n    await this.#processInit(initOptions)\n\n    this.onReady?.(this.authenticated)\n\n    return this.authenticated\n  }\n\n  /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */\n  #loadAdapter (type) {\n    if (type === 'default') {\n      return this.#loadDefaultAdapter()\n    }\n\n    if (type === 'cordova') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaAdapter()\n    }\n\n    if (type === 'cordova-native') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaNativeAdapter()\n    }\n\n    throw new Error('invalid adapter type: ' + type)\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadDefaultAdapter () {\n    /** @type {KeycloakAdapter['redirectUri']}{} */\n    const redirectUri = (options) => {\n      return options?.redirectUri || this.redirectUri || globalThis.location.href\n    }\n\n    return {\n      login: async (options) => {\n        window.location.assign(await this.createLoginUrl(options))\n        return await new Promise(() => {})\n      },\n\n      logout: async (options) => {\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n\n        if (logoutMethod === 'GET') {\n          window.location.replace(this.createLogoutUrl(options))\n          return\n        }\n\n        // Create form to send POST request.\n        const form = document.createElement('form')\n\n        form.setAttribute('method', 'POST')\n        form.setAttribute('action', this.createLogoutUrl(options))\n        form.style.display = 'none'\n\n        // Add data to form as hidden input fields.\n        const data = {\n          id_token_hint: this.idToken,\n          client_id: this.clientId,\n          post_logout_redirect_uri: redirectUri(options)\n        }\n\n        for (const [name, value] of Object.entries(data)) {\n          const input = document.createElement('input')\n\n          input.setAttribute('type', 'hidden')\n          input.setAttribute('name', name)\n          input.setAttribute('value', /** @type {string} */ (value))\n\n          form.appendChild(input)\n        }\n\n        // Append form to page and submit it to perform logout and redirect.\n        document.body.appendChild(form)\n        form.submit()\n      },\n\n      register: async (options) => {\n        window.location.assign(await this.createRegisterUrl(options))\n        return await new Promise(() => {})\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.location.href = accountUrl\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return await new Promise(() => {})\n      },\n\n      redirectUri\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaAdapter () {\n    /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */\n    const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n      if (window.cordova && window.cordova.InAppBrowser) {\n        // Use inappbrowser for IOS and Android if available\n        return window.cordova.InAppBrowser.open(loginUrl, target, options)\n      } else {\n        return window.open(loginUrl, target, options)\n      }\n    }\n\n    const shallowCloneCordovaOptions = (userOptions) => {\n      if (userOptions && userOptions.cordovaOptions) {\n        return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n          options[optionName] = userOptions.cordovaOptions[optionName]\n          return options\n        }, {})\n      } else {\n        return {}\n      }\n    }\n\n    const formatCordovaOptions = (cordovaOptions) => {\n      return Object.keys(cordovaOptions).reduce((options, optionName) => {\n        options.push(optionName + '=' + cordovaOptions[optionName])\n        return options\n      }, []).join(',')\n    }\n\n    const createCordovaOptions = (userOptions) => {\n      const cordovaOptions = shallowCloneCordovaOptions(userOptions)\n      cordovaOptions.location = 'no'\n      if (userOptions && userOptions.prompt === 'none') {\n        cordovaOptions.hidden = 'yes'\n      }\n      return formatCordovaOptions(cordovaOptions)\n    }\n\n    const getCordovaRedirectUri = () => {\n      return this.redirectUri || 'http://localhost'\n    }\n\n    return {\n      login: async (options) => {\n        const cordovaOptions = createCordovaOptions(options)\n        const loginUrl = await this.createLoginUrl(options)\n        const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions)\n        let completed = false\n        let closed = false\n\n        function closeBrowser () {\n          closed = true\n          ref.close()\n        };\n\n        return await new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(callback)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n              closeBrowser()\n              completed = true\n            }\n          })\n\n          ref.addEventListener('loaderror', async (event) => {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                const callback = this.#parseCallback(event.url)\n                try {\n                  await this.#processCallback(callback)\n                  resolve()\n                } catch (error) {\n                  reject(error)\n                }\n                closeBrowser()\n                completed = true\n              } else {\n                reject(new Error('Unable to process login.'))\n                closeBrowser()\n              }\n            }\n          })\n\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              reject(new Error('User closed the login window.'))\n            }\n          })\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n        const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes')\n        let error = false\n\n        ref.addEventListener('loadstart', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          }\n        })\n\n        ref.addEventListener('loaderror', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          } else {\n            error = true\n            ref.close()\n          }\n        })\n\n        await new Promise((resolve, reject) => {\n          ref.addEventListener('exit', () => {\n            if (error) {\n              reject(new Error('User closed the login window.'))\n            } else {\n              this.clearToken()\n              resolve()\n            }\n          })\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl()\n        const cordovaOptions = createCordovaOptions(options)\n        const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions)\n\n        /** @type {Promise<void>} */\n        const promise = new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n              const oauth = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(oauth)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n            }\n          })\n        })\n\n        await promise\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no')\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n            }\n          })\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: () => {\n        return getCordovaRedirectUri()\n      }\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaNativeAdapter () {\n    /* global universalLinks */\n    return {\n      login: async (options) => {\n        const loginUrl = await this.createLoginUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(loginUrl)\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n\n        await new Promise((resolve) => {\n          universalLinks.subscribe('keycloak', () => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            this.clearToken()\n            resolve()\n          })\n\n          window.cordova.plugins.browsertab.openUrl(logoutUrl)\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(registerUrl)\n        })\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.cordova.plugins.browsertab.openUrl(accountUrl)\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: (options) => {\n        if (options && options.redirectUri) {\n          return options.redirectUri\n        } else if (this.redirectUri) {\n          return this.redirectUri\n        } else {\n          return 'http://localhost'\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #loadConfig () {\n    if (typeof this.#config === 'string') {\n      const jsonConfig = await fetchJsonConfig(this.#config)\n      this.authServerUrl = jsonConfig['auth-server-url']\n      this.realm = jsonConfig.realm\n      this.clientId = jsonConfig.resource\n      this.#setupEndpoints()\n    } else {\n      this.clientId = this.#config.clientId\n\n      if ('oidcProvider' in this.#config) {\n        await this.#loadOidcConfig(this.#config.oidcProvider)\n      } else {\n        this.authServerUrl = this.#config.url\n        this.realm = this.#config.realm\n        this.#setupEndpoints()\n      }\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  #setupEndpoints () {\n    this.endpoints = {\n      authorize: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/auth'\n      },\n      token: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/token'\n      },\n      logout: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/logout'\n      },\n      checkSessionIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html'\n      },\n      thirdPartyCookiesIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html'\n      },\n      register: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/registrations'\n      },\n      userinfo: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/userinfo'\n      }\n    }\n  }\n\n  /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */\n  async #loadOidcConfig (oidcProvider) {\n    if (typeof oidcProvider === 'string') {\n      const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`\n      const openIdConfig = await fetchOpenIdConfig(url)\n      this.#setupOidcEndpoints(openIdConfig)\n    } else {\n      this.#setupOidcEndpoints(oidcProvider)\n    }\n  }\n\n  /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */\n  #setupOidcEndpoints (config) {\n    this.endpoints = {\n      authorize () {\n        return config.authorization_endpoint\n      },\n      token () {\n        return config.token_endpoint\n      },\n      logout () {\n        if (!config.end_session_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.end_session_endpoint\n      },\n      checkSessionIframe () {\n        if (!config.check_session_iframe) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.check_session_iframe\n      },\n      register () {\n        throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode')\n      },\n      userinfo () {\n        if (!config.userinfo_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.userinfo_endpoint\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #check3pCookiesSupported () {\n    if ((!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri) || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-3p-check-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = (event) => {\n        if (iframe.contentWindow !== event.source) {\n          return\n        }\n\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return\n        } else if (event.data === 'unsupported') {\n          this.#logWarn(\n            '[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' +\n                        ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' +\n                        ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' +\n                        'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers'\n          )\n\n          this.#loginIframe.enable = false\n          if (this.silentCheckSsoFallback) {\n            this.silentCheckSsoRedirectUri = undefined\n          }\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n        resolve()\n      }\n\n      window.addEventListener('message', messageCallback, false)\n    })\n\n    return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.')\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */\n  async #processInit (initOptions) {\n    const callback = this.#parseCallback(window.location.href)\n\n    if (callback?.redirectUri) {\n      window.history.replaceState(window.history.state, '', callback.redirectUri)\n    }\n\n    if (callback && callback.valid) {\n      await this.#setupCheckLoginIframe()\n      await this.#processCallback(callback)\n      return\n    }\n\n    /** @param {boolean} prompt */\n    const doLogin = async (prompt) => {\n      /** @type {KeycloakLoginOptions} */\n      const options = {}\n\n      if (!prompt) {\n        options.prompt = 'none'\n      }\n\n      if (initOptions.locale) {\n        options.locale = initOptions.locale\n      }\n\n      await this.login(options)\n    }\n\n    const onLoad = async () => {\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (this.#loginIframe.enable) {\n            await this.#setupCheckLoginIframe()\n            const unchanged = await this.#checkLoginIframe()\n\n            if (!unchanged) {\n              this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n            }\n          } else {\n            this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n          }\n          break\n        case 'login-required':\n          await doLogin(true)\n          break\n        default:\n          throw new Error('Invalid value for onLoad')\n      }\n    }\n\n    if (initOptions.token && initOptions.refreshToken) {\n      this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken)\n\n      if (this.#loginIframe.enable) {\n        await this.#setupCheckLoginIframe()\n        const unchanged = await this.#checkLoginIframe()\n\n        if (unchanged) {\n          this.onAuthSuccess?.()\n          this.#scheduleCheckIframe()\n        }\n      } else {\n        try {\n          await this.updateToken(-1)\n          this.onAuthSuccess?.()\n        } catch (error) {\n          this.onAuthError?.()\n          if (initOptions.onLoad) {\n            await onLoad()\n          } else {\n            throw error\n          }\n        }\n      }\n    } else if (initOptions.onLoad) {\n      await onLoad()\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #setupCheckLoginIframe () {\n    if (!this.#loginIframe.enable || this.#loginIframe.iframe) {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    this.#loginIframe.iframe = iframe\n    iframe.setAttribute('src', this.endpoints.checkSessionIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-session-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = (event) => {\n      if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) {\n        return\n      }\n\n      if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n        return\n      }\n\n      if (event.data !== 'unchanged') {\n        this.clearToken()\n      }\n\n      const callbacks = this.#loginIframe.callbackList\n      this.#loginIframe.callbackList = []\n\n      for (const callback of callbacks.reverse()) {\n        if (event.data === 'error') {\n          callback(new Error('Error while checking login iframe'))\n        } else {\n          callback(null, event.data === 'unchanged')\n        }\n      }\n    }\n\n    window.addEventListener('message', messageCallback, false)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      iframe.addEventListener('load', () => {\n        const authUrl = this.endpoints.authorize()\n        if (authUrl.startsWith('/')) {\n          this.#loginIframe.iframeOrigin = globalThis.location.origin\n        } else {\n          this.#loginIframe.iframeOrigin = new URL(authUrl).origin\n        }\n        resolve()\n      })\n    })\n\n    await promise\n  }\n\n  /**\n   * @returns {Promise<boolean | undefined>}\n   */\n  async #checkLoginIframe () {\n    if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) {\n      return\n    }\n\n    const message = `${this.clientId} ${(this.sessionId ? this.sessionId : '')}`\n    const origin = this.#loginIframe.iframeOrigin\n\n    /** @type {Promise<boolean>} */\n    const promise = new Promise((resolve, reject) => {\n      /** @type {(error: Error | null, value?: boolean) => void} */\n      const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */ (result))\n\n      this.#loginIframe.callbackList.push(callback)\n\n      if (this.#loginIframe.callbackList.length === 1) {\n        this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin)\n      }\n    })\n\n    return await promise\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #checkSsoSilently () {\n    const iframe = document.createElement('iframe')\n    const src = await this.createLoginUrl({ prompt: 'none', redirectUri: this.silentCheckSsoRedirectUri })\n    iframe.setAttribute('src', src)\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-silent-check-sso')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    return await new Promise((resolve, reject) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = async (event) => {\n        if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n          return\n        }\n\n        const oauth = this.#parseCallback(event.data)\n\n        try {\n          await this.#processCallback(oauth)\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n      }\n\n      window.addEventListener('message', messageCallback)\n    })\n  };\n\n  /**\n   * @param {string} url\n   */\n  #parseCallback (url) {\n    const oauth = this.#parseCallbackUrl(url)\n    if (!oauth) {\n      return\n    }\n\n    const oauthState = this.#callbackStorage.get(oauth.state)\n\n    if (oauthState) {\n      oauth.valid = true\n      oauth.redirectUri = oauthState.redirectUri\n      oauth.storedNonce = oauthState.nonce\n      oauth.prompt = oauthState.prompt\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier\n      oauth.loginOptions = oauthState.loginOptions\n    }\n\n    return oauth\n  }\n\n  /**\n   * @param {string} urlString\n   */\n  #parseCallbackUrl (urlString) {\n    let supportedParams = []\n    switch (this.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n    }\n\n    supportedParams.push('error')\n    supportedParams.push('error_description')\n    supportedParams.push('error_uri')\n\n    const url = new URL(urlString)\n    let redirectUri = ''\n    let parsed\n\n    if (this.responseMode === 'query' && url.searchParams.size > 0) {\n      parsed = this.#parseCallbackParams(url.search, supportedParams)\n      url.search = parsed.paramsString\n      redirectUri = url.toString()\n    } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n      parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams)\n      url.hash = ''\n      redirectUri = url.toString()\n    }\n\n    if (parsed?.oauthParams) {\n      if (this.flow === 'standard' || this.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      } else if (this.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */\n\n  /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */\n  #parseCallbackParams (paramsString, supportedParams) {\n    const params = new URLSearchParams(paramsString)\n    /** @type {Record<string, string>} */\n    const oauthParams = {}\n\n    for (const [key, value] of Array.from(params.entries())) {\n      if (supportedParams.includes(key)) {\n        oauthParams[key] = value\n        params.delete(key)\n      }\n    }\n\n    return {\n      paramsString: params.toString(),\n      oauthParams\n    }\n  }\n\n  async #processCallback (oauth) {\n    const { code, error, prompt } = oauth\n    let timeLocal = new Date().getTime()\n\n    /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */\n    const authSuccess = (accessToken, refreshToken, idToken) => {\n      timeLocal = (timeLocal + new Date().getTime()) / 2\n\n      this.#setToken(accessToken, refreshToken, idToken, timeLocal)\n\n      if (this.#useNonce && (this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce)) {\n        this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token')\n        this.clearToken()\n        throw new Error('Invalid nonce.')\n      }\n    }\n\n    if (oauth.kc_action_status) {\n      this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action)\n    }\n\n    if (error) {\n      if (prompt !== 'none') {\n        if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n          await this.login(oauth.loginOptions)\n        } else {\n          const errorData = { error, error_description: oauth.error_description }\n          this.onAuthError?.(errorData)\n          throw errorData\n        }\n      }\n      return\n    } else if ((this.flow !== 'standard') && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, undefined, oauth.id_token)\n      this.onAuthSuccess?.()\n    }\n\n    if ((this.flow !== 'implicit') && code) {\n      try {\n        const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */ (this.clientId), oauth.redirectUri, oauth.pkceCodeVerifier)\n        authSuccess(response.access_token, response.refresh_token, response.id_token)\n\n        if (this.flow === 'standard') {\n          this.onAuthSuccess?.()\n        }\n\n        this.#scheduleCheckIframe()\n      } catch (error) {\n        this.onAuthError?.()\n        throw error\n      }\n    }\n  }\n\n  async #scheduleCheckIframe () {\n    if (this.#loginIframe.enable && this.token) {\n      await waitForTimeout(this.#loginIframe.interval * 1000)\n      const unchanged = await this.#checkLoginIframe()\n\n      if (unchanged) {\n        await this.#scheduleCheckIframe()\n      }\n    }\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login (options) {\n    return this.#adapter.login(options)\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  async createLoginUrl (options) {\n    const state = createUUID()\n    const nonce = createUUID()\n    const redirectUri = this.#adapter.redirectUri(options)\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    }\n\n    if (options?.prompt) {\n      callbackState.prompt = options.prompt\n    }\n\n    const url = options?.action === 'register'\n      ? this.endpoints.register()\n      : this.endpoints.authorize()\n\n    let scope = options?.scope || this.scope\n    const scopeValues = scope ? scope.split(' ') : []\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid')\n    }\n\n    scope = scopeValues.join(' ')\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      // The endpoint URI MUST NOT include a fragment component.\n      // https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\n      ['redirect_uri', stripHash(redirectUri)],\n      ['state', state],\n      ['response_mode', this.responseMode],\n      ['response_type', this.responseType],\n      ['scope', scope]\n    ])\n\n    if (this.#useNonce) {\n      params.append('nonce', nonce)\n    }\n\n    if (options?.prompt) {\n      params.append('prompt', options.prompt)\n    }\n\n    if (typeof options?.maxAge === 'number') {\n      params.append('max_age', options.maxAge.toString())\n    }\n\n    if (options?.loginHint) {\n      params.append('login_hint', options.loginHint)\n    }\n\n    if (options?.idpHint) {\n      params.append('kc_idp_hint', options.idpHint)\n    }\n\n    if (options?.action && options.action !== 'register') {\n      params.append('kc_action', options.action)\n    }\n\n    if (options?.locale) {\n      params.append('ui_locales', options.locale)\n    }\n\n    if (options?.acr) {\n      params.append('claims', buildClaimsParameter(options.acr))\n    }\n\n    if (options?.acrValues) {\n      params.append('acr_values', options.acrValues)\n    }\n\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96)\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier)\n\n        callbackState.pkceCodeVerifier = codeVerifier\n\n        params.append('code_challenge', pkceChallenge)\n        params.append('code_challenge_method', this.pkceMethod)\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', { cause: error })\n      }\n    }\n\n    this.#callbackStorage.add(callbackState)\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout (options) {\n    return this.#adapter.logout(options)\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl (options) {\n    const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n    const url = this.endpoints.logout()\n\n    if (logoutMethod === 'POST') {\n      return url\n    }\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      ['post_logout_redirect_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken)\n    }\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register (options) {\n    return this.#adapter.register(options)\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl (options) {\n    return this.createLoginUrl({ ...options, action: 'register' })\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl (options) {\n    const url = this.#getRealmUrl()\n\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const params = new URLSearchParams([\n      ['referrer', /** @type {string} */ (this.clientId)],\n      ['referrer_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    return `${url}/account?${params.toString()}`\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement () {\n    return this.#adapter.accountManagement()\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole (role) {\n    const access = this.realmAccess\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole (role, resource) {\n    if (!this.resourceAccess) {\n      return false\n    }\n\n    const access = this.resourceAccess[resource || /** @type {string} */ (this.clientId)]\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  async loadUserProfile () {\n    const realmUrl = this.#getRealmUrl()\n\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const url = `${realmUrl}/account`\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.profile = profile)\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  async loadUserInfo () {\n    const url = this.endpoints.userinfo()\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.userInfo = userInfo)\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired (minValidity) {\n    if (!this.tokenParsed || (!this.refreshToken && this.flow !== 'implicit')) {\n      throw new Error('Not authenticated')\n    }\n\n    if (this.timeSkew == null) {\n      this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set')\n      return true\n    }\n\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false\n    }\n\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity')\n      }\n      expiresIn -= minValidity\n    }\n    return expiresIn < 0\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  async updateToken (minValidity) {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.')\n    }\n\n    minValidity = minValidity || 5\n\n    if (this.#loginIframe.enable) {\n      await this.#checkLoginIframe()\n    }\n\n    let refreshToken = false\n\n    if (minValidity === -1) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh')\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: token expired')\n    }\n\n    if (!refreshToken) {\n      return false\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const { promise, resolve, reject } = Promise.withResolvers()\n\n    this.#refreshQueue.push({ resolve, reject })\n\n    if (this.#refreshQueue.length === 1) {\n      const url = this.endpoints.token()\n      let timeLocal = new Date().getTime()\n\n      try {\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */ (this.clientId))\n        this.#logInfo('[KEYCLOAK] Token refreshed')\n\n        timeLocal = (timeLocal + new Date().getTime()) / 2\n\n        this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal)\n\n        this.onAuthRefreshSuccess?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.resolve(true)\n        }\n      } catch (error) {\n        this.#logWarn('[KEYCLOAK] Failed to refresh token')\n\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken()\n        }\n\n        this.onAuthRefreshError?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.reject(error)\n        }\n      }\n    }\n\n    return await promise\n  }\n\n  clearToken () {\n    if (this.token) {\n      this.#setToken()\n      this.onAuthLogout?.()\n      if (this.loginRequired) {\n        this.login()\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n  #setToken (token, refreshToken, idToken, timeLocal) {\n    if (this.tokenTimeoutHandle) {\n      clearTimeout(this.tokenTimeoutHandle)\n      this.tokenTimeoutHandle = undefined\n    }\n\n    if (refreshToken) {\n      this.refreshToken = refreshToken\n      this.refreshTokenParsed = decodeToken(refreshToken)\n    } else {\n      delete this.refreshToken\n      delete this.refreshTokenParsed\n    }\n\n    if (idToken) {\n      this.idToken = idToken\n      this.idTokenParsed = decodeToken(idToken)\n    } else {\n      delete this.idToken\n      delete this.idTokenParsed\n    }\n\n    if (token) {\n      this.token = token\n      this.tokenParsed = decodeToken(token)\n      this.sessionId = this.tokenParsed.sid\n      this.authenticated = true\n      this.subject = this.tokenParsed.sub\n      this.realmAccess = this.tokenParsed.realm_access\n      this.resourceAccess = this.tokenParsed.resource_access\n\n      if (timeLocal) {\n        this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat\n      }\n\n      if (this.timeSkew !== null) {\n        this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds')\n\n        if (this.onTokenExpired) {\n          const expiresIn = (this.tokenParsed.exp - (new Date().getTime() / 1000) + this.timeSkew) * 1000\n          this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s')\n          if (expiresIn <= 0) {\n            this.onTokenExpired()\n          } else {\n            this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn)\n          }\n        }\n      }\n    } else {\n      delete this.token\n      delete this.tokenParsed\n      delete this.subject\n      delete this.realmAccess\n      delete this.resourceAccess\n\n      this.authenticated = false\n    }\n  }\n\n  /**\n   * @returns {string=}\n   */\n  #getRealmUrl () {\n    if (typeof this.authServerUrl === 'undefined') {\n      return\n    }\n\n    return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */ (this.realm))}`\n  }\n\n  /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */\n  #createLogger (fn) {\n    return (message) => {\n      if (this.enableLogging) {\n        fn.call(console, message)\n      }\n    }\n  }\n}\n\n/**\n * @returns {string}\n */\nfunction createUUID () {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.randomUUID()\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter (requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  })\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier (len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge (pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`)\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier))\n  const encodedHash = bytesToBase64(hashBytes)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n\n  return encodedHash\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString (len, alphabet) {\n  const randomData = generateRandomData(len)\n  const chars = new Array(len)\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length)\n  }\n  return String.fromCharCode.apply(null, chars)\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData (len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.getRandomValues(new Uint8Array(len))\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise (promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'))\n    }, timeout)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle)\n  })\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage () {\n  try {\n    return new LocalStorage()\n  } catch (err) {\n    return new CookieStorage()\n  }\n}\n\nconst STORAGE_KEY_PREFIX = 'kc-callback-'\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nclass LocalStorage {\n  constructor () {\n    globalThis.localStorage.setItem('kc-test', 'test')\n    globalThis.localStorage.removeItem('kc-test')\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state\n    const value = globalThis.localStorage.getItem(key)\n\n    if (value) {\n      globalThis.localStorage.removeItem(key)\n      return JSON.parse(value)\n    }\n\n    return null\n  };\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state.state\n    const value = JSON.stringify({\n      ...state,\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + (60 * 60 * 1000)\n    })\n\n    try {\n      globalThis.localStorage.setItem(key, value)\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      this.#clearAllValues()\n      globalThis.localStorage.setItem(key, value)\n    }\n  };\n\n  /**\n   * Clears all values from local storage that are no longer valid.\n   */\n  #clearInvalidValues () {\n    const currentTime = Date.now()\n\n    for (const [key, value] of this.#getStoredEntries()) {\n      // Attempt to parse the expiry time from the value.\n      const expiry = this.#parseExpiry(value)\n\n      // Discard the value if it is malformed or expired.\n      if (expiry === null || expiry < currentTime) {\n        globalThis.localStorage.removeItem(key)\n      }\n    }\n  }\n\n  /**\n   * Clears all known values from local storage.\n   */\n  #clearAllValues () {\n    for (const [key] of this.#getStoredEntries()) {\n      globalThis.localStorage.removeItem(key)\n    }\n  }\n\n  /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */\n  #getStoredEntries () {\n    return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX))\n  }\n\n  /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */\n  #parseExpiry (value) {\n    let parsedValue\n\n    // Attempt to parse the value as JSON.\n    try {\n      parsedValue = JSON.parse(value)\n    } catch (error) {\n      return null\n    }\n\n    // Attempt to extract the 'expires' property.\n    if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n      return parsedValue.expires\n    }\n\n    return null\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nclass CookieStorage {\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    const value = this.#getCookie(STORAGE_KEY_PREFIX + state)\n    this.#setCookie(STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100))\n    if (value) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60))\n  }\n\n  /**\n   * @param {string} key\n   * @returns\n   */\n  #getCookie (key) {\n    const name = key + '='\n    const ca = document.cookie.split(';')\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i]\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1)\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length)\n      }\n    }\n    return ''\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */\n  #setCookie (key, value, expirationDate) {\n    const cookie = key + '=' + value + '; ' +\n            'expires=' + expirationDate.toUTCString() + '; '\n    document.cookie = cookie\n  }\n\n  /**\n   * @param {number} minutes\n   * @returns {Date}\n   */\n  #cookieExpiration (minutes) {\n    const exp = new Date()\n    exp.setTime(exp.getTime() + (minutes * 60 * 1000))\n    return exp\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64 (bytes) {\n  const binString = String.fromCodePoint(...bytes)\n  return btoa(binString)\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest (message) {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(message)\n\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return await crypto.subtle.digest('SHA-256', data)\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken (token) {\n  const [, payload] = token.split('.')\n\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.')\n  }\n\n  let decoded\n\n  try {\n    decoded = base64UrlDecode(payload)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', { cause: error })\n  }\n\n  try {\n    return JSON.parse(decoded)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', { cause: error })\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode (input) {\n  let output = input\n    .replaceAll('-', '+')\n    .replaceAll('_', '/')\n\n  switch (output.length % 4) {\n    case 0:\n      break\n    case 2:\n      output += '=='\n      break\n    case 3:\n      output += '='\n      break\n    default:\n      throw new Error('Input is not of the correct length.')\n  }\n\n  try {\n    return b64DecodeUnicode(output)\n  } catch (error) {\n    return atob(output)\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode (input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase()\n\n    if (code.length < 2) {\n      code = '0' + code\n    }\n\n    return '%' + code\n  }))\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject (input) {\n  return typeof input === 'object' && input !== null\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken (url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([\n    ['code', code],\n    ['grant_type', 'authorization_code'],\n    ['client_id', clientId],\n    ['redirect_uri', stripHash(redirectUri)]\n  ])\n\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier)\n  }\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken (url, refreshToken, clientId) {\n  const body = new URLSearchParams([\n    ['grant_type', 'refresh_token'],\n    ['refresh_token', refreshToken],\n    ['client_id', clientId]\n  ])\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON (url, init = {}) {\n  const headers = new Headers(init.headers)\n  headers.set('Accept', CONTENT_TYPE_JSON)\n\n  const response = await fetchWithErrorHandling(url, {\n    ...init,\n    headers\n  })\n\n  return await response.json()\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling (url, init) {\n  const response = await fetch(url, init)\n\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', { response })\n  }\n\n  return response\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader (token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.')\n  }\n\n  return ['Authorization', `bearer ${token}`]\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash (url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash (url) {\n  const parsedUrl = new URL(url)\n  parsedUrl.hash = ''\n  return parsedUrl.toString()\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nclass NetworkError extends Error {\n  /** @type {Response} */\n  response\n\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor (message, options) {\n    super(message, options)\n    this.response = options.response\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2tleWNsb2FrLWpzL2xpYi9rZXljbG9hay5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQSxZQUFZLDJWQUEyVjtBQUN2VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QixjQUFjLGNBQWM7QUFDNUIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxvREFBb0Q7QUFDbEUsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsU0FBUztBQUN2Qjs7QUFFZTtBQUNmLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNB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O0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE1BQU07QUFDM0M7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCLGFBQWEsOENBQThDO0FBQzNEOztBQUVPO0FBQ1AsYUFBYSxVQUFVO0FBQ3ZCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWVudG8tbW9yaS1hZG1pbi1wb3J0YWwvLi4vLi4vbm9kZV9tb2R1bGVzL2tleWNsb2FrLWpzL2xpYi9rZXljbG9hay5qcz8yZjY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuLyoqXG4gKiBAaW1wb3J0IHtBY3IsIEtleWNsb2FrQWNjb3VudE9wdGlvbnMsIEtleWNsb2FrQWRhcHRlciwgS2V5Y2xvYWtDb25maWcsIEtleWNsb2FrRXJyb3IsIEtleWNsb2FrRmxvdywgS2V5Y2xvYWtJbml0T3B0aW9ucywgS2V5Y2xvYWtMb2dpbk9wdGlvbnMsIEtleWNsb2FrTG9nb3V0T3B0aW9ucywgS2V5Y2xvYWtQa2NlTWV0aG9kLCBLZXljbG9ha1Byb2ZpbGUsIEtleWNsb2FrUmVnaXN0ZXJPcHRpb25zLCBLZXljbG9ha1Jlc291cmNlQWNjZXNzLCBLZXljbG9ha1Jlc3BvbnNlTW9kZSwgS2V5Y2xvYWtSZXNwb25zZVR5cGUsIEtleWNsb2FrUm9sZXMsIEtleWNsb2FrVG9rZW5QYXJzZWQsIE9wZW5JZFByb3ZpZGVyTWV0YWRhdGF9IGZyb20gXCIuL2tleWNsb2FrLnRzXCJcbiAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE2IFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzXG4gKiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIGFzIGluZGljYXRlZCBieSB0aGUgQGF1dGhvciB0YWdzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IENPTlRFTlRfVFlQRV9KU09OID0gJ2FwcGxpY2F0aW9uL2pzb24nXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW5kcG9pbnRzXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gYXV0aG9yaXplXG4gKiBAcHJvcGVydHkgeygpID0+IHN0cmluZ30gdG9rZW5cbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nfSBsb2dvdXRcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nfSBjaGVja1Nlc3Npb25JZnJhbWVcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nPX0gdGhpcmRQYXJ0eUNvb2tpZXNJZnJhbWVcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nfSByZWdpc3RlclxuICogQHByb3BlcnR5IHsoKSA9PiBzdHJpbmd9IHVzZXJpbmZvXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dpbklmcmFtZVxuICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVcbiAqIEBwcm9wZXJ0eSB7KChlcnJvcjogRXJyb3IgfCBudWxsLCB2YWx1ZT86IGJvb2xlYW4pID0+IHZvaWQpW119IGNhbGxiYWNrTGlzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludGVydmFsXG4gKiBAcHJvcGVydHkge0hUTUxJRnJhbWVFbGVtZW50PX0gaWZyYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGlmcmFtZU9yaWdpblxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWNsb2FrIHtcbiAgLyoqIEB0eXBlIHtQaWNrPFByb21pc2VXaXRoUmVzb2x2ZXJzPGJvb2xlYW4+LCAncmVzb2x2ZScgfCAncmVqZWN0Jz5bXX0gKi9cbiAgI3JlZnJlc2hRdWV1ZSA9IFtdXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtBZGFwdGVyfSAqL1xuICAjYWRhcHRlclxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICN1c2VOb25jZSA9IHRydWVcbiAgLyoqIEB0eXBlIHtDYWxsYmFja1N0b3JhZ2V9ICovXG4gICNjYWxsYmFja1N0b3JhZ2VcbiAgI2xvZ0luZm8gPSB0aGlzLiNjcmVhdGVMb2dnZXIoY29uc29sZS5pbmZvKVxuICAjbG9nV2FybiA9IHRoaXMuI2NyZWF0ZUxvZ2dlcihjb25zb2xlLndhcm4pXG4gIC8qKiBAdHlwZSB7TG9naW5JZnJhbWV9ICovXG4gICNsb2dpbklmcmFtZSA9IHtcbiAgICBlbmFibGU6IHRydWUsXG4gICAgY2FsbGJhY2tMaXN0OiBbXSxcbiAgICBpbnRlcnZhbDogNVxuICB9XG5cbiAgLyoqIEB0eXBlIHtLZXljbG9ha0NvbmZpZ30gY29uZmlnICovXG4gICNjb25maWdcbiAgZGlkSW5pdGlhbGl6ZSA9IGZhbHNlXG4gIGF1dGhlbnRpY2F0ZWQgPSBmYWxzZVxuICBsb2dpblJlcXVpcmVkID0gZmFsc2VcbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Jlc3BvbnNlTW9kZX0gKi9cbiAgcmVzcG9uc2VNb2RlID0gJ2ZyYWdtZW50J1xuICAvKiogQHR5cGUge0tleWNsb2FrUmVzcG9uc2VUeXBlfSAqL1xuICByZXNwb25zZVR5cGUgPSAnY29kZSdcbiAgLyoqIEB0eXBlIHtLZXljbG9ha0Zsb3d9ICovXG4gIGZsb3cgPSAnc3RhbmRhcmQnXG4gIC8qKiBAdHlwZSB7bnVtYmVyP30gKi9cbiAgdGltZVNrZXcgPSBudWxsXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgcmVkaXJlY3RVcmlcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBzaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgc2lsZW50Q2hlY2tTc29GYWxsYmFjayA9IHRydWVcbiAgLyoqIEB0eXBlIHtLZXljbG9ha1BrY2VNZXRob2R9ICovXG4gIHBrY2VNZXRob2QgPSAnUzI1NidcbiAgZW5hYmxlTG9nZ2luZyA9IGZhbHNlXG4gIC8qKiBAdHlwZSB7J0dFVCcgfCAnUE9TVCd9ICovXG4gIGxvZ291dE1ldGhvZCA9ICdHRVQnXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgc2NvcGVcbiAgbWVzc2FnZVJlY2VpdmVUaW1lb3V0ID0gMTAwMDBcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBpZFRva2VuXG4gIC8qKiBAdHlwZSB7S2V5Y2xvYWtUb2tlblBhcnNlZD19ICovXG4gIGlkVG9rZW5QYXJzZWRcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICB0b2tlblxuICAvKiogQHR5cGUge0tleWNsb2FrVG9rZW5QYXJzZWQ9fSAqL1xuICB0b2tlblBhcnNlZFxuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHJlZnJlc2hUb2tlblxuICAvKiogQHR5cGUge0tleWNsb2FrVG9rZW5QYXJzZWQ9fSAqL1xuICByZWZyZXNoVG9rZW5QYXJzZWRcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBjbGllbnRJZFxuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHNlc3Npb25JZFxuICAvKiogQHR5cGUge3N0cmluZz19ICovXG4gIHN1YmplY3RcbiAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICBhdXRoU2VydmVyVXJsXG4gIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgcmVhbG1cbiAgLyoqIEB0eXBlIHtLZXljbG9ha1JvbGVzPX0gKi9cbiAgcmVhbG1BY2Nlc3NcbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Jlc291cmNlQWNjZXNzPX0gKi9cbiAgcmVzb3VyY2VBY2Nlc3NcbiAgLyoqIEB0eXBlIHtLZXljbG9ha1Byb2ZpbGU9fSAqL1xuICBwcm9maWxlXG4gIC8qKiBAdHlwZSB7e309fSAqL1xuICB1c2VySW5mb1xuICAvKiogQHR5cGUge0VuZHBvaW50c30gKi9cbiAgZW5kcG9pbnRzXG4gIC8qKiBAdHlwZSB7bnVtYmVyPX0gKi9cbiAgdG9rZW5UaW1lb3V0SGFuZGxlXG4gIC8qKiBAdHlwZSB7KCkgPT4gdm9pZD19ICovXG4gIG9uQXV0aFN1Y2Nlc3NcbiAgLyoqIEB0eXBlIHsoZXJyb3JEYXRhPzogS2V5Y2xvYWtFcnJvcikgPT4gdm9pZD19ICovXG4gIG9uQXV0aEVycm9yXG4gIC8qKiBAdHlwZSB7KCkgPT4gdm9pZD19ICovXG4gIG9uQXV0aFJlZnJlc2hTdWNjZXNzXG4gIC8qKiBAdHlwZSB7KCkgPT4gdm9pZD19ICovXG4gIG9uQXV0aFJlZnJlc2hFcnJvclxuICAvKiogQHR5cGUgeygpID0+IHZvaWQ9fSAqL1xuICBvblRva2VuRXhwaXJlZFxuICAvKiogQHR5cGUgeygpID0+IHZvaWQ9fSAqL1xuICBvbkF1dGhMb2dvdXRcbiAgLyoqIEB0eXBlIHsoYXV0aGVudGljYXRlZDogYm9vbGVhbikgPT4gdm9pZD19ICovXG4gIG9uUmVhZHlcbiAgLyoqIEB0eXBlIHsoc3RhdHVzOiAnc3VjY2VzcycgfCAnY2FuY2VsbGVkJyB8ICdlcnJvcicsIGFjdGlvbjogc3RyaW5nKSA9PiB2b2lkPX0gKi9cbiAgb25BY3Rpb25VcGRhdGVcblxuICAvKipcbiAgICogQHBhcmFtIHtLZXljbG9ha0NvbmZpZ30gY29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnICYmICFpc09iamVjdChjb25maWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ0tleWNsb2FrJyBjb25zdHJ1Y3RvciBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSBjb25maWd1cmF0aW9uIG9iamVjdCwgb3IgYSBVUkwgdG8gYSBKU09OIGNvbmZpZ3VyYXRpb24gZmlsZS5cIilcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgY29uc3QgcmVxdWlyZWRQcm9wZXJ0aWVzID0gJ29pZGNQcm92aWRlcicgaW4gY29uZmlnXG4gICAgICAgID8gWydjbGllbnRJZCddXG4gICAgICAgIDogWyd1cmwnLCAncmVhbG0nLCAnY2xpZW50SWQnXVxuXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHJlcXVpcmVkUHJvcGVydGllcykge1xuICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiBjb25maWcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgaXMgbWlzc2luZyB0aGUgcmVxdWlyZWQgJyR7cHJvcGVydHl9JyBwcm9wZXJ0eS5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnbG9iYWxUaGlzLmlzU2VjdXJlQ29udGV4dCkge1xuICAgICAgdGhpcy4jbG9nV2FybihcbiAgICAgICAgXCJbS0VZQ0xPQUtdIEtleWNsb2FrIEpTIG11c3QgYmUgdXNlZCBpbiBhICdzZWN1cmUgY29udGV4dCcgdG8gZnVuY3Rpb24gcHJvcGVybHkgYXMgaXQgcmVsaWVzIG9uIGJyb3dzZXIgQVBJcyB0aGF0IGFyZSBvdGhlcndpc2Ugbm90IGF2YWlsYWJsZS5cXG5cIiArXG4gICAgICAgICAgICAgICAgJ0NvbnRpbnVpbmcgdG8gcnVuIHlvdXIgYXBwbGljYXRpb24gaW5zZWN1cmVseSB3aWxsIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBhbmQgYnJlYWthZ2UuXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgJ0ZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2VjdXJlX0NvbnRleHRzJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuI2NvbmZpZyA9IGNvbmZpZ1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtJbml0T3B0aW9uc30gaW5pdE9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBpbml0IChpbml0T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuZGlkSW5pdGlhbGl6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSAnS2V5Y2xvYWsnIGluc3RhbmNlIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2UuXCIpXG4gICAgfVxuXG4gICAgdGhpcy5kaWRJbml0aWFsaXplID0gdHJ1ZVxuICAgIHRoaXMuI2NhbGxiYWNrU3RvcmFnZSA9IGNyZWF0ZUNhbGxiYWNrU3RvcmFnZSgpXG5cbiAgICBjb25zdCBhZGFwdGVycyA9IFsnZGVmYXVsdCcsICdjb3Jkb3ZhJywgJ2NvcmRvdmEtbmF0aXZlJ11cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuYWRhcHRlciA9PT0gJ3N0cmluZycgJiYgYWRhcHRlcnMuaW5jbHVkZXMoaW5pdE9wdGlvbnMuYWRhcHRlcikpIHtcbiAgICAgIHRoaXMuI2FkYXB0ZXIgPSB0aGlzLiNsb2FkQWRhcHRlcihpbml0T3B0aW9ucy5hZGFwdGVyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluaXRPcHRpb25zLmFkYXB0ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLiNhZGFwdGVyID0gaW5pdE9wdGlvbnMuYWRhcHRlclxuICAgIH0gZWxzZSBpZiAoJ0NvcmRvdmEnIGluIHdpbmRvdyB8fCAnY29yZG92YScgaW4gd2luZG93KSB7XG4gICAgICB0aGlzLiNhZGFwdGVyID0gdGhpcy4jbG9hZEFkYXB0ZXIoJ2NvcmRvdmEnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNhZGFwdGVyID0gdGhpcy4jbG9hZEFkYXB0ZXIoJ2RlZmF1bHQnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMudXNlTm9uY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLiN1c2VOb25jZSA9IGluaXRPcHRpb25zLnVzZU5vbmNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5jaGVja0xvZ2luSWZyYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlID0gaW5pdE9wdGlvbnMuY2hlY2tMb2dpbklmcmFtZVxuICAgIH1cblxuICAgIGlmIChpbml0T3B0aW9ucy5jaGVja0xvZ2luSWZyYW1lSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmludGVydmFsID0gaW5pdE9wdGlvbnMuY2hlY2tMb2dpbklmcmFtZUludGVydmFsXG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLm9uTG9hZCA9PT0gJ2xvZ2luLXJlcXVpcmVkJykge1xuICAgICAgdGhpcy5sb2dpblJlcXVpcmVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChpbml0T3B0aW9ucy5yZXNwb25zZU1vZGUpIHtcbiAgICAgIGlmIChpbml0T3B0aW9ucy5yZXNwb25zZU1vZGUgPT09ICdxdWVyeScgfHwgaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlID09PSAnZnJhZ21lbnQnKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VNb2RlID0gaW5pdE9wdGlvbnMucmVzcG9uc2VNb2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHJlc3BvbnNlTW9kZScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLmZsb3cpIHtcbiAgICAgIHN3aXRjaCAoaW5pdE9wdGlvbnMuZmxvdykge1xuICAgICAgICBjYXNlICdzdGFuZGFyZCc6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnY29kZSdcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSAnaWRfdG9rZW4gdG9rZW4nXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaHlicmlkJzpcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICdjb2RlIGlkX3Rva2VuIHRva2VuJ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBmbG93JylcbiAgICAgIH1cbiAgICAgIHRoaXMuZmxvdyA9IGluaXRPcHRpb25zLmZsb3dcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluaXRPcHRpb25zLnRpbWVTa2V3ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy50aW1lU2tldyA9IGluaXRPcHRpb25zLnRpbWVTa2V3XG4gICAgfVxuXG4gICAgaWYgKGluaXRPcHRpb25zLnJlZGlyZWN0VXJpKSB7XG4gICAgICB0aGlzLnJlZGlyZWN0VXJpID0gaW5pdE9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICB9XG5cbiAgICBpZiAoaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaSkge1xuICAgICAgdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID0gaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29SZWRpcmVjdFVyaVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMuc2lsZW50Q2hlY2tTc29GYWxsYmFjayA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNpbGVudENoZWNrU3NvRmFsbGJhY2sgPSBpbml0T3B0aW9ucy5zaWxlbnRDaGVja1Nzb0ZhbGxiYWNrXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5wa2NlTWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGluaXRPcHRpb25zLnBrY2VNZXRob2QgIT09ICdTMjU2JyAmJiBpbml0T3B0aW9ucy5wa2NlTWV0aG9kICE9PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBwa2NlTWV0aG9kJywgZXhwZWN0ZWQgJ1MyNTYnIG9yIGZhbHNlIGJ1dCBnb3QgJHtpbml0T3B0aW9ucy5wa2NlTWV0aG9kfS5gKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBrY2VNZXRob2QgPSBpbml0T3B0aW9ucy5wa2NlTWV0aG9kXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5lbmFibGVMb2dnaW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZW5hYmxlTG9nZ2luZyA9IGluaXRPcHRpb25zLmVuYWJsZUxvZ2dpbmdcbiAgICB9XG5cbiAgICBpZiAoaW5pdE9wdGlvbnMubG9nb3V0TWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgIHRoaXMubG9nb3V0TWV0aG9kID0gJ1BPU1QnXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbml0T3B0aW9ucy5zY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2NvcGUgPSBpbml0T3B0aW9ucy5zY29wZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5pdE9wdGlvbnMubWVzc2FnZVJlY2VpdmVUaW1lb3V0ID09PSAnbnVtYmVyJyAmJiBpbml0T3B0aW9ucy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQgPiAwKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VSZWNlaXZlVGltZW91dCA9IGluaXRPcHRpb25zLm1lc3NhZ2VSZWNlaXZlVGltZW91dFxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuI2xvYWRDb25maWcoKVxuICAgIGF3YWl0IHRoaXMuI2NoZWNrM3BDb29raWVzU3VwcG9ydGVkKClcbiAgICBhd2FpdCB0aGlzLiNwcm9jZXNzSW5pdChpbml0T3B0aW9ucylcblxuICAgIHRoaXMub25SZWFkeT8uKHRoaXMuYXV0aGVudGljYXRlZClcblxuICAgIHJldHVybiB0aGlzLmF1dGhlbnRpY2F0ZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1wiZGVmYXVsdFwiIHwgXCJjb3Jkb3ZhXCIgfCBcImNvcmRvdmEtbmF0aXZlXCJ9IHR5cGVcbiAgICogQHJldHVybnMge0tleWNsb2FrQWRhcHRlcn1cbiAgICovXG4gICNsb2FkQWRhcHRlciAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLiNsb2FkRGVmYXVsdEFkYXB0ZXIoKVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnY29yZG92YScpIHtcbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSA9IGZhbHNlXG4gICAgICByZXR1cm4gdGhpcy4jbG9hZENvcmRvdmFBZGFwdGVyKClcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NvcmRvdmEtbmF0aXZlJykge1xuICAgICAgdGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlID0gZmFsc2VcbiAgICAgIHJldHVybiB0aGlzLiNsb2FkQ29yZG92YU5hdGl2ZUFkYXB0ZXIoKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGFwdGVyIHR5cGU6ICcgKyB0eXBlKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtLZXljbG9ha0FkYXB0ZXJ9XG4gICAqL1xuICAjbG9hZERlZmF1bHRBZGFwdGVyICgpIHtcbiAgICAvKiogQHR5cGUge0tleWNsb2FrQWRhcHRlclsncmVkaXJlY3RVcmknXX17fSAqL1xuICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiBvcHRpb25zPy5yZWRpcmVjdFVyaSB8fCB0aGlzLnJlZGlyZWN0VXJpIHx8IGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZlxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsb2dpbjogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihhd2FpdCB0aGlzLmNyZWF0ZUxvZ2luVXJsKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9LFxuXG4gICAgICBsb2dvdXQ6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvZ291dE1ldGhvZCA9IG9wdGlvbnM/LmxvZ291dE1ldGhvZCA/PyB0aGlzLmxvZ291dE1ldGhvZFxuXG4gICAgICAgIGlmIChsb2dvdXRNZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodGhpcy5jcmVhdGVMb2dvdXRVcmwob3B0aW9ucykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgZm9ybSB0byBzZW5kIFBPU1QgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKVxuXG4gICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnUE9TVCcpXG4gICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY3Rpb24nLCB0aGlzLmNyZWF0ZUxvZ291dFVybChvcHRpb25zKSlcbiAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICAgICAgLy8gQWRkIGRhdGEgdG8gZm9ybSBhcyBoaWRkZW4gaW5wdXQgZmllbGRzLlxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgIGlkX3Rva2VuX2hpbnQ6IHRoaXMuaWRUb2tlbixcbiAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpOiByZWRpcmVjdFVyaShvcHRpb25zKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG5cbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaGlkZGVuJylcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBuYW1lKVxuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHZhbHVlKSlcblxuICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgZm9ybSB0byBwYWdlIGFuZCBzdWJtaXQgaXQgdG8gcGVyZm9ybSBsb2dvdXQgYW5kIHJlZGlyZWN0LlxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pXG4gICAgICAgIGZvcm0uc3VibWl0KClcbiAgICAgIH0sXG5cbiAgICAgIHJlZ2lzdGVyOiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGF3YWl0IHRoaXMuY3JlYXRlUmVnaXN0ZXJVcmwob3B0aW9ucykpXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH0sXG5cbiAgICAgIGFjY291bnRNYW5hZ2VtZW50OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRVcmwgPSB0aGlzLmNyZWF0ZUFjY291bnRVcmwoKVxuICAgICAgICBpZiAodHlwZW9mIGFjY291bnRVcmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhY2NvdW50VXJsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBPSURDIHNlcnZlcicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfSxcblxuICAgICAgcmVkaXJlY3RVcmlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0tleWNsb2FrQWRhcHRlcn1cbiAgICovXG4gICNsb2FkQ29yZG92YUFkYXB0ZXIgKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpblVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtXaW5kb3dQcm94eSB8IG51bGx9XG4gICAgICovXG4gICAgY29uc3QgY29yZG92YU9wZW5XaW5kb3dXcmFwcGVyID0gKGxvZ2luVXJsLCB0YXJnZXQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5JbkFwcEJyb3dzZXIpIHtcbiAgICAgICAgLy8gVXNlIGluYXBwYnJvd3NlciBmb3IgSU9TIGFuZCBBbmRyb2lkIGlmIGF2YWlsYWJsZVxuICAgICAgICByZXR1cm4gd2luZG93LmNvcmRvdmEuSW5BcHBCcm93c2VyLm9wZW4obG9naW5VcmwsIHRhcmdldCwgb3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cub3Blbihsb2dpblVybCwgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNoYWxsb3dDbG9uZUNvcmRvdmFPcHRpb25zID0gKHVzZXJPcHRpb25zKSA9PiB7XG4gICAgICBpZiAodXNlck9wdGlvbnMgJiYgdXNlck9wdGlvbnMuY29yZG92YU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHVzZXJPcHRpb25zLmNvcmRvdmFPcHRpb25zKS5yZWR1Y2UoKG9wdGlvbnMsIG9wdGlvbk5hbWUpID0+IHtcbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdXNlck9wdGlvbnMuY29yZG92YU9wdGlvbnNbb3B0aW9uTmFtZV1cbiAgICAgICAgICByZXR1cm4gb3B0aW9uc1xuICAgICAgICB9LCB7fSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdENvcmRvdmFPcHRpb25zID0gKGNvcmRvdmFPcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29yZG92YU9wdGlvbnMpLnJlZHVjZSgob3B0aW9ucywgb3B0aW9uTmFtZSkgPT4ge1xuICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uTmFtZSArICc9JyArIGNvcmRvdmFPcHRpb25zW29wdGlvbk5hbWVdKVxuICAgICAgICByZXR1cm4gb3B0aW9uc1xuICAgICAgfSwgW10pLmpvaW4oJywnKVxuICAgIH1cblxuICAgIGNvbnN0IGNyZWF0ZUNvcmRvdmFPcHRpb25zID0gKHVzZXJPcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBjb3Jkb3ZhT3B0aW9ucyA9IHNoYWxsb3dDbG9uZUNvcmRvdmFPcHRpb25zKHVzZXJPcHRpb25zKVxuICAgICAgY29yZG92YU9wdGlvbnMubG9jYXRpb24gPSAnbm8nXG4gICAgICBpZiAodXNlck9wdGlvbnMgJiYgdXNlck9wdGlvbnMucHJvbXB0ID09PSAnbm9uZScpIHtcbiAgICAgICAgY29yZG92YU9wdGlvbnMuaGlkZGVuID0gJ3llcydcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JtYXRDb3Jkb3ZhT3B0aW9ucyhjb3Jkb3ZhT3B0aW9ucylcbiAgICB9XG5cbiAgICBjb25zdCBnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVyaSB8fCAnaHR0cDovL2xvY2FsaG9zdCdcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9naW46IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvcmRvdmFPcHRpb25zID0gY3JlYXRlQ29yZG92YU9wdGlvbnMob3B0aW9ucylcbiAgICAgICAgY29uc3QgbG9naW5VcmwgPSBhd2FpdCB0aGlzLmNyZWF0ZUxvZ2luVXJsKG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IHJlZiA9IGNvcmRvdmFPcGVuV2luZG93V3JhcHBlcihsb2dpblVybCwgJ19ibGFuaycsIGNvcmRvdmFPcHRpb25zKVxuICAgICAgICBsZXQgY29tcGxldGVkID0gZmFsc2VcbiAgICAgICAgbGV0IGNsb3NlZCA9IGZhbHNlXG5cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VCcm93c2VyICgpIHtcbiAgICAgICAgICBjbG9zZWQgPSB0cnVlXG4gICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC51cmwuaW5kZXhPZihnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkoKSkgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLiNwYXJzZUNhbGxiYWNrKGV2ZW50LnVybClcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Byb2Nlc3NDYWxsYmFjayhjYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2xvc2VCcm93c2VyKClcbiAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVycm9yJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YoZ2V0Q29yZG92YVJlZGlyZWN0VXJpKCkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLiNwYXJzZUNhbGxiYWNrKGV2ZW50LnVybClcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VCcm93c2VyKClcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIHByb2Nlc3MgbG9naW4uJykpXG4gICAgICAgICAgICAgICAgY2xvc2VCcm93c2VyKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignZXhpdCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVXNlciBjbG9zZWQgdGhlIGxvZ2luIHdpbmRvdy4nKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgbG9nb3V0OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBsb2dvdXRVcmwgPSB0aGlzLmNyZWF0ZUxvZ291dFVybChvcHRpb25zKVxuICAgICAgICBjb25zdCByZWYgPSBjb3Jkb3ZhT3BlbldpbmRvd1dyYXBwZXIobG9nb3V0VXJsLCAnX2JsYW5rJywgJ2xvY2F0aW9uPW5vLGhpZGRlbj15ZXMsY2xlYXJjYWNoZT15ZXMnKVxuICAgICAgICBsZXQgZXJyb3IgPSBmYWxzZVxuXG4gICAgICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQudXJsLmluZGV4T2YoZ2V0Q29yZG92YVJlZGlyZWN0VXJpKCkpID09PSAwKSB7XG4gICAgICAgICAgICByZWYuY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PT0gMCkge1xuICAgICAgICAgICAgcmVmLmNsb3NlKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSB0cnVlXG4gICAgICAgICAgICByZWYuY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2V4aXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVXNlciBjbG9zZWQgdGhlIGxvZ2luIHdpbmRvdy4nKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbigpXG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuXG4gICAgICByZWdpc3RlcjogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJVcmwgPSBhd2FpdCB0aGlzLmNyZWF0ZVJlZ2lzdGVyVXJsKClcbiAgICAgICAgY29uc3QgY29yZG92YU9wdGlvbnMgPSBjcmVhdGVDb3Jkb3ZhT3B0aW9ucyhvcHRpb25zKVxuICAgICAgICBjb25zdCByZWYgPSBjb3Jkb3ZhT3BlbldpbmRvd1dyYXBwZXIocmVnaXN0ZXJVcmwsICdfYmxhbmsnLCBjb3Jkb3ZhT3B0aW9ucylcblxuICAgICAgICAvKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PT0gMCkge1xuICAgICAgICAgICAgICByZWYuY2xvc2UoKVxuICAgICAgICAgICAgICBjb25zdCBvYXV0aCA9IHRoaXMuI3BhcnNlQ2FsbGJhY2soZXZlbnQudXJsKVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvY2Vzc0NhbGxiYWNrKG9hdXRoKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgfSxcblxuICAgICAgYWNjb3VudE1hbmFnZW1lbnQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudFVybCA9IHRoaXMuY3JlYXRlQWNjb3VudFVybCgpXG4gICAgICAgIGlmICh0eXBlb2YgYWNjb3VudFVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSBjb3Jkb3ZhT3BlbldpbmRvd1dyYXBwZXIoYWNjb3VudFVybCwgJ19ibGFuaycsICdsb2NhdGlvbj1ubycpXG4gICAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnVybC5pbmRleE9mKGdldENvcmRvdmFSZWRpcmVjdFVyaSgpKSA9PT0gMCkge1xuICAgICAgICAgICAgICByZWYuY2xvc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIGJ5IHRoZSBPSURDIHNlcnZlcicpXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlZGlyZWN0VXJpOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRDb3Jkb3ZhUmVkaXJlY3RVcmkoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7S2V5Y2xvYWtBZGFwdGVyfVxuICAgKi9cbiAgI2xvYWRDb3Jkb3ZhTmF0aXZlQWRhcHRlciAoKSB7XG4gICAgLyogZ2xvYmFsIHVuaXZlcnNhbExpbmtzICovXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZ2luOiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBsb2dpblVybCA9IGF3YWl0IHRoaXMuY3JlYXRlTG9naW5Vcmwob3B0aW9ucylcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdW5pdmVyc2FsTGlua3Muc3Vic2NyaWJlKCdrZXljbG9haycsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdW5pdmVyc2FsTGlua3MudW5zdWJzY3JpYmUoJ2tleWNsb2FrJylcbiAgICAgICAgICAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5jbG9zZSgpXG4gICAgICAgICAgICBjb25zdCBvYXV0aCA9IHRoaXMuI3BhcnNlQ2FsbGJhY2soZXZlbnQudXJsKVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm9jZXNzQ2FsbGJhY2sob2F1dGgpXG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybChsb2dpblVybClcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIGxvZ291dDogYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgbG9nb3V0VXJsID0gdGhpcy5jcmVhdGVMb2dvdXRVcmwob3B0aW9ucylcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHVuaXZlcnNhbExpbmtzLnN1YnNjcmliZSgna2V5Y2xvYWsnLCAoKSA9PiB7XG4gICAgICAgICAgICB1bml2ZXJzYWxMaW5rcy51bnN1YnNjcmliZSgna2V5Y2xvYWsnKVxuICAgICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLmNsb3NlKClcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUb2tlbigpXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmwobG9nb3V0VXJsKVxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgcmVnaXN0ZXI6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVXJsID0gYXdhaXQgdGhpcy5jcmVhdGVSZWdpc3RlclVybChvcHRpb25zKVxuXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB1bml2ZXJzYWxMaW5rcy5zdWJzY3JpYmUoJ2tleWNsb2FrJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1bml2ZXJzYWxMaW5rcy51bnN1YnNjcmliZSgna2V5Y2xvYWsnKVxuICAgICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLmNsb3NlKClcbiAgICAgICAgICAgIGNvbnN0IG9hdXRoID0gdGhpcy4jcGFyc2VDYWxsYmFjayhldmVudC51cmwpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNwcm9jZXNzQ2FsbGJhY2sob2F1dGgpXG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybChyZWdpc3RlclVybClcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIGFjY291bnRNYW5hZ2VtZW50OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRVcmwgPSB0aGlzLmNyZWF0ZUFjY291bnRVcmwoKVxuICAgICAgICBpZiAodHlwZW9mIGFjY291bnRVcmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5icm93c2VydGFiLm9wZW5VcmwoYWNjb3VudFVybClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgYnkgdGhlIE9JREMgc2VydmVyJylcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVkaXJlY3RVcmk6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RVcmkpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWRpcmVjdFVyaVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVkaXJlY3RVcmkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVyaVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnaHR0cDovL2xvY2FsaG9zdCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNsb2FkQ29uZmlnICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuI2NvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGpzb25Db25maWcgPSBhd2FpdCBmZXRjaEpzb25Db25maWcodGhpcy4jY29uZmlnKVxuICAgICAgdGhpcy5hdXRoU2VydmVyVXJsID0ganNvbkNvbmZpZ1snYXV0aC1zZXJ2ZXItdXJsJ11cbiAgICAgIHRoaXMucmVhbG0gPSBqc29uQ29uZmlnLnJlYWxtXG4gICAgICB0aGlzLmNsaWVudElkID0ganNvbkNvbmZpZy5yZXNvdXJjZVxuICAgICAgdGhpcy4jc2V0dXBFbmRwb2ludHMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsaWVudElkID0gdGhpcy4jY29uZmlnLmNsaWVudElkXG5cbiAgICAgIGlmICgnb2lkY1Byb3ZpZGVyJyBpbiB0aGlzLiNjb25maWcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jbG9hZE9pZGNDb25maWcodGhpcy4jY29uZmlnLm9pZGNQcm92aWRlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXV0aFNlcnZlclVybCA9IHRoaXMuI2NvbmZpZy51cmxcbiAgICAgICAgdGhpcy5yZWFsbSA9IHRoaXMuI2NvbmZpZy5yZWFsbVxuICAgICAgICB0aGlzLiNzZXR1cEVuZHBvaW50cygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgI3NldHVwRW5kcG9pbnRzICgpIHtcbiAgICB0aGlzLmVuZHBvaW50cyA9IHtcbiAgICAgIGF1dGhvcml6ZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvYXV0aCdcbiAgICAgIH0sXG4gICAgICB0b2tlbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvdG9rZW4nXG4gICAgICB9LFxuICAgICAgbG9nb3V0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRSZWFsbVVybCgpICsgJy9wcm90b2NvbC9vcGVuaWQtY29ubmVjdC9sb2dvdXQnXG4gICAgICB9LFxuICAgICAgY2hlY2tTZXNzaW9uSWZyYW1lOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnZXRSZWFsbVVybCgpICsgJy9wcm90b2NvbC9vcGVuaWQtY29ubmVjdC9sb2dpbi1zdGF0dXMtaWZyYW1lLmh0bWwnXG4gICAgICB9LFxuICAgICAgdGhpcmRQYXJ0eUNvb2tpZXNJZnJhbWU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldFJlYWxtVXJsKCkgKyAnL3Byb3RvY29sL29wZW5pZC1jb25uZWN0LzNwLWNvb2tpZXMvc3RlcDEuaHRtbCdcbiAgICAgIH0sXG4gICAgICByZWdpc3RlcjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvcmVnaXN0cmF0aW9ucydcbiAgICAgIH0sXG4gICAgICB1c2VyaW5mbzogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0UmVhbG1VcmwoKSArICcvcHJvdG9jb2wvb3BlbmlkLWNvbm5lY3QvdXNlcmluZm8nXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgT3BlbklkUHJvdmlkZXJNZXRhZGF0YX0gb2lkY1Byb3ZpZGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI2xvYWRPaWRjQ29uZmlnIChvaWRjUHJvdmlkZXIpIHtcbiAgICBpZiAodHlwZW9mIG9pZGNQcm92aWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHVybCA9IGAke3N0cmlwVHJhaWxpbmdTbGFzaChvaWRjUHJvdmlkZXIpfS8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbmBcbiAgICAgIGNvbnN0IG9wZW5JZENvbmZpZyA9IGF3YWl0IGZldGNoT3BlbklkQ29uZmlnKHVybClcbiAgICAgIHRoaXMuI3NldHVwT2lkY0VuZHBvaW50cyhvcGVuSWRDb25maWcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3NldHVwT2lkY0VuZHBvaW50cyhvaWRjUHJvdmlkZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T3BlbklkUHJvdmlkZXJNZXRhZGF0YX0gY29uZmlnXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgI3NldHVwT2lkY0VuZHBvaW50cyAoY29uZmlnKSB7XG4gICAgdGhpcy5lbmRwb2ludHMgPSB7XG4gICAgICBhdXRob3JpemUgKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmF1dGhvcml6YXRpb25fZW5kcG9pbnRcbiAgICAgIH0sXG4gICAgICB0b2tlbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25maWcudG9rZW5fZW5kcG9pbnRcbiAgICAgIH0sXG4gICAgICBsb2dvdXQgKCkge1xuICAgICAgICBpZiAoIWNvbmZpZy5lbmRfc2Vzc2lvbl9lbmRwb2ludCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXInKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWcuZW5kX3Nlc3Npb25fZW5kcG9pbnRcbiAgICAgIH0sXG4gICAgICBjaGVja1Nlc3Npb25JZnJhbWUgKCkge1xuICAgICAgICBpZiAoIWNvbmZpZy5jaGVja19zZXNzaW9uX2lmcmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXInKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWcuY2hlY2tfc2Vzc2lvbl9pZnJhbWVcbiAgICAgIH0sXG4gICAgICByZWdpc3RlciAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkaXJlY3Rpb24gdG8gXCJSZWdpc3RlciB1c2VyXCIgcGFnZSBub3Qgc3VwcG9ydGVkIGluIHN0YW5kYXJkIE9JREMgbW9kZScpXG4gICAgICB9LFxuICAgICAgdXNlcmluZm8gKCkge1xuICAgICAgICBpZiAoIWNvbmZpZy51c2VyaW5mb19lbmRwb2ludCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBieSB0aGUgT0lEQyBzZXJ2ZXInKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWcudXNlcmluZm9fZW5kcG9pbnRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyAjY2hlY2szcENvb2tpZXNTdXBwb3J0ZWQgKCkge1xuICAgIGlmICgoIXRoaXMuI2xvZ2luSWZyYW1lLmVuYWJsZSAmJiAhdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpKSB8fCB0eXBlb2YgdGhpcy5lbmRwb2ludHMudGhpcmRQYXJ0eUNvb2tpZXNJZnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5lbmRwb2ludHMudGhpcmRQYXJ0eUNvb2tpZXNJZnJhbWUoKSlcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJ2FsbG93LXN0b3JhZ2UtYWNjZXNzLWJ5LXVzZXItYWN0aXZhdGlvbiBhbGxvdy1zY3JpcHRzIGFsbG93LXNhbWUtb3JpZ2luJylcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd0aXRsZScsICdrZXljbG9hay0zcC1jaGVjay1pZnJhbWUnKVxuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG5cbiAgICAvKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudFxuICAgICAgICovXG4gICAgICBjb25zdCBtZXNzYWdlQ2FsbGJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlmcmFtZS5jb250ZW50V2luZG93ICE9PSBldmVudC5zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5kYXRhICE9PSAnc3VwcG9ydGVkJyAmJiBldmVudC5kYXRhICE9PSAndW5zdXBwb3J0ZWQnKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YSA9PT0gJ3Vuc3VwcG9ydGVkJykge1xuICAgICAgICAgIHRoaXMuI2xvZ1dhcm4oXG4gICAgICAgICAgICAnW0tFWUNMT0FLXSBZb3VyIGJyb3dzZXIgaXMgYmxvY2tpbmcgYWNjZXNzIHRvIDNyZC1wYXJ0eSBjb29raWVzLCB0aGlzIG1lYW5zOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAtIEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXRyaWV2ZSB0b2tlbnMgd2l0aG91dCByZWRpcmVjdGluZyB0byB0aGUgS2V5Y2xvYWsgc2VydmVyIChhLmsuYS4gbm8gc3VwcG9ydCBmb3Igc2lsZW50IGF1dGhlbnRpY2F0aW9uKS5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgLSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXV0b21hdGljYWxseSBkZXRlY3QgY2hhbmdlcyB0byB0aGUgc2Vzc2lvbiBzdGF0dXMgKHN1Y2ggYXMgdGhlIHVzZXIgbG9nZ2luZyBvdXQgaW4gYW5vdGhlciB0YWIpLlxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTogaHR0cHM6Ly93d3cua2V5Y2xvYWsub3JnL3NlY3VyaW5nLWFwcHMvamF2YXNjcmlwdC1hZGFwdGVyI19tb2Rlcm5fYnJvd3NlcnMnXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgdGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlID0gZmFsc2VcbiAgICAgICAgICBpZiAodGhpcy5zaWxlbnRDaGVja1Nzb0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNpbGVudENoZWNrU3NvUmVkaXJlY3RVcmkgPSB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSlcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlQ2FsbGJhY2spXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VDYWxsYmFjaywgZmFsc2UpXG4gICAgfSlcblxuICAgIHJldHVybiBhd2FpdCBhcHBseVRpbWVvdXRUb1Byb21pc2UocHJvbWlzZSwgdGhpcy5tZXNzYWdlUmVjZWl2ZVRpbWVvdXQsICdUaW1lb3V0IHdoZW4gd2FpdGluZyBmb3IgM3JkIHBhcnR5IGNoZWNrIGlmcmFtZSBtZXNzYWdlLicpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtLZXljbG9ha0luaXRPcHRpb25zfSBpbml0T3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNwcm9jZXNzSW5pdCAoaW5pdE9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuI3BhcnNlQ2FsbGJhY2sod2luZG93LmxvY2F0aW9uLmhyZWYpXG5cbiAgICBpZiAoY2FsbGJhY2s/LnJlZGlyZWN0VXJpKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUod2luZG93Lmhpc3Rvcnkuc3RhdGUsICcnLCBjYWxsYmFjay5yZWRpcmVjdFVyaSlcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sudmFsaWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3NldHVwQ2hlY2tMb2dpbklmcmFtZSgpXG4gICAgICBhd2FpdCB0aGlzLiNwcm9jZXNzQ2FsbGJhY2soY2FsbGJhY2spXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtib29sZWFufSBwcm9tcHQgKi9cbiAgICBjb25zdCBkb0xvZ2luID0gYXN5bmMgKHByb21wdCkgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtLZXljbG9ha0xvZ2luT3B0aW9uc30gKi9cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fVxuXG4gICAgICBpZiAoIXByb21wdCkge1xuICAgICAgICBvcHRpb25zLnByb21wdCA9ICdub25lJ1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdE9wdGlvbnMubG9jYWxlKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gaW5pdE9wdGlvbnMubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMubG9naW4ob3B0aW9ucylcbiAgICB9XG5cbiAgICBjb25zdCBvbkxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGluaXRPcHRpb25zLm9uTG9hZCkge1xuICAgICAgICBjYXNlICdjaGVjay1zc28nOlxuICAgICAgICAgIGlmICh0aGlzLiNsb2dpbklmcmFtZS5lbmFibGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3NldHVwQ2hlY2tMb2dpbklmcmFtZSgpXG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSBhd2FpdCB0aGlzLiNjaGVja0xvZ2luSWZyYW1lKClcblxuICAgICAgICAgICAgaWYgKCF1bmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID8gYXdhaXQgdGhpcy4jY2hlY2tTc29TaWxlbnRseSgpIDogYXdhaXQgZG9Mb2dpbihmYWxzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpID8gYXdhaXQgdGhpcy4jY2hlY2tTc29TaWxlbnRseSgpIDogYXdhaXQgZG9Mb2dpbihmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnbG9naW4tcmVxdWlyZWQnOlxuICAgICAgICAgIGF3YWl0IGRvTG9naW4odHJ1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb25Mb2FkJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5pdE9wdGlvbnMudG9rZW4gJiYgaW5pdE9wdGlvbnMucmVmcmVzaFRva2VuKSB7XG4gICAgICB0aGlzLiNzZXRUb2tlbihpbml0T3B0aW9ucy50b2tlbiwgaW5pdE9wdGlvbnMucmVmcmVzaFRva2VuLCBpbml0T3B0aW9ucy5pZFRva2VuKVxuXG4gICAgICBpZiAodGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3NldHVwQ2hlY2tMb2dpbklmcmFtZSgpXG4gICAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGF3YWl0IHRoaXMuI2NoZWNrTG9naW5JZnJhbWUoKVxuXG4gICAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFN1Y2Nlc3M/LigpXG4gICAgICAgICAgdGhpcy4jc2NoZWR1bGVDaGVja0lmcmFtZSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVUb2tlbigtMSlcbiAgICAgICAgICB0aGlzLm9uQXV0aFN1Y2Nlc3M/LigpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhFcnJvcj8uKClcbiAgICAgICAgICBpZiAoaW5pdE9wdGlvbnMub25Mb2FkKSB7XG4gICAgICAgICAgICBhd2FpdCBvbkxvYWQoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5pdE9wdGlvbnMub25Mb2FkKSB7XG4gICAgICBhd2FpdCBvbkxvYWQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNzZXR1cENoZWNrTG9naW5JZnJhbWUgKCkge1xuICAgIGlmICghdGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlIHx8IHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICB0aGlzLiNsb2dpbklmcmFtZS5pZnJhbWUgPSBpZnJhbWVcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLmVuZHBvaW50cy5jaGVja1Nlc3Npb25JZnJhbWUoKSlcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJ2FsbG93LXN0b3JhZ2UtYWNjZXNzLWJ5LXVzZXItYWN0aXZhdGlvbiBhbGxvdy1zY3JpcHRzIGFsbG93LXNhbWUtb3JpZ2luJylcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd0aXRsZScsICdrZXljbG9hay1zZXNzaW9uLWlmcmFtZScpXG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSlcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fSBldmVudFxuICAgICAqL1xuICAgIGNvbnN0IG1lc3NhZ2VDYWxsYmFjayA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy4jbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luIHx8IHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZT8uY29udGVudFdpbmRvdyAhPT0gZXZlbnQuc291cmNlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIShldmVudC5kYXRhID09PSAndW5jaGFuZ2VkJyB8fCBldmVudC5kYXRhID09PSAnY2hhbmdlZCcgfHwgZXZlbnQuZGF0YSA9PT0gJ2Vycm9yJykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5kYXRhICE9PSAndW5jaGFuZ2VkJykge1xuICAgICAgICB0aGlzLmNsZWFyVG9rZW4oKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLiNsb2dpbklmcmFtZS5jYWxsYmFja0xpc3RcbiAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmNhbGxiYWNrTGlzdCA9IFtdXG5cbiAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzLnJldmVyc2UoKSkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRXJyb3Igd2hpbGUgY2hlY2tpbmcgbG9naW4gaWZyYW1lJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZXZlbnQuZGF0YSA9PT0gJ3VuY2hhbmdlZCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VDYWxsYmFjaywgZmFsc2UpXG5cbiAgICAvKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXV0aFVybCA9IHRoaXMuZW5kcG9pbnRzLmF1dGhvcml6ZSgpXG4gICAgICAgIGlmIChhdXRoVXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZU9yaWdpbiA9IGdsb2JhbFRoaXMubG9jYXRpb24ub3JpZ2luXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luID0gbmV3IFVSTChhdXRoVXJsKS5vcmlnaW5cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGF3YWl0IHByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuIHwgdW5kZWZpbmVkPn1cbiAgICovXG4gIGFzeW5jICNjaGVja0xvZ2luSWZyYW1lICgpIHtcbiAgICBpZiAoIXRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZSB8fCAhdGhpcy4jbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gYCR7dGhpcy5jbGllbnRJZH0gJHsodGhpcy5zZXNzaW9uSWQgPyB0aGlzLnNlc3Npb25JZCA6ICcnKX1gXG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy4jbG9naW5JZnJhbWUuaWZyYW1lT3JpZ2luXG5cbiAgICAvKiogQHR5cGUge1Byb21pc2U8Ym9vbGVhbj59ICovXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7KGVycm9yOiBFcnJvciB8IG51bGwsIHZhbHVlPzogYm9vbGVhbikgPT4gdm9pZH0gKi9cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoLyoqIEB0eXBlIHtib29sZWFufSAqLyAocmVzdWx0KSlcblxuICAgICAgdGhpcy4jbG9naW5JZnJhbWUuY2FsbGJhY2tMaXN0LnB1c2goY2FsbGJhY2spXG5cbiAgICAgIGlmICh0aGlzLiNsb2dpbklmcmFtZS5jYWxsYmFja0xpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuI2xvZ2luSWZyYW1lLmlmcmFtZT8uY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI2NoZWNrU3NvU2lsZW50bHkgKCkge1xuICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgY29uc3Qgc3JjID0gYXdhaXQgdGhpcy5jcmVhdGVMb2dpblVybCh7IHByb21wdDogJ25vbmUnLCByZWRpcmVjdFVyaTogdGhpcy5zaWxlbnRDaGVja1Nzb1JlZGlyZWN0VXJpIH0pXG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKVxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NhbmRib3gnLCAnYWxsb3ctc3RvcmFnZS1hY2Nlc3MtYnktdXNlci1hY3RpdmF0aW9uIGFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW4nKVxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2tleWNsb2FrLXNpbGVudC1jaGVjay1zc28nKVxuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgY29uc3QgbWVzc2FnZUNhbGxiYWNrID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgaWZyYW1lLmNvbnRlbnRXaW5kb3cgIT09IGV2ZW50LnNvdXJjZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2F1dGggPSB0aGlzLiNwYXJzZUNhbGxiYWNrKGV2ZW50LmRhdGEpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLiNwcm9jZXNzQ2FsbGJhY2sob2F1dGgpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZUNhbGxiYWNrKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VDYWxsYmFjaylcbiAgICB9KVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICAjcGFyc2VDYWxsYmFjayAodXJsKSB7XG4gICAgY29uc3Qgb2F1dGggPSB0aGlzLiNwYXJzZUNhbGxiYWNrVXJsKHVybClcbiAgICBpZiAoIW9hdXRoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBvYXV0aFN0YXRlID0gdGhpcy4jY2FsbGJhY2tTdG9yYWdlLmdldChvYXV0aC5zdGF0ZSlcblxuICAgIGlmIChvYXV0aFN0YXRlKSB7XG4gICAgICBvYXV0aC52YWxpZCA9IHRydWVcbiAgICAgIG9hdXRoLnJlZGlyZWN0VXJpID0gb2F1dGhTdGF0ZS5yZWRpcmVjdFVyaVxuICAgICAgb2F1dGguc3RvcmVkTm9uY2UgPSBvYXV0aFN0YXRlLm5vbmNlXG4gICAgICBvYXV0aC5wcm9tcHQgPSBvYXV0aFN0YXRlLnByb21wdFxuICAgICAgb2F1dGgucGtjZUNvZGVWZXJpZmllciA9IG9hdXRoU3RhdGUucGtjZUNvZGVWZXJpZmllclxuICAgICAgb2F1dGgubG9naW5PcHRpb25zID0gb2F1dGhTdGF0ZS5sb2dpbk9wdGlvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gb2F1dGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nXG4gICAqL1xuICAjcGFyc2VDYWxsYmFja1VybCAodXJsU3RyaW5nKSB7XG4gICAgbGV0IHN1cHBvcnRlZFBhcmFtcyA9IFtdXG4gICAgc3dpdGNoICh0aGlzLmZsb3cpIHtcbiAgICAgIGNhc2UgJ3N0YW5kYXJkJzpcbiAgICAgICAgc3VwcG9ydGVkUGFyYW1zID0gWydjb2RlJywgJ3N0YXRlJywgJ3Nlc3Npb25fc3RhdGUnLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2ltcGxpY2l0JzpcbiAgICAgICAgc3VwcG9ydGVkUGFyYW1zID0gWydhY2Nlc3NfdG9rZW4nLCAndG9rZW5fdHlwZScsICdpZF90b2tlbicsICdzdGF0ZScsICdzZXNzaW9uX3N0YXRlJywgJ2V4cGlyZXNfaW4nLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2h5YnJpZCc6XG4gICAgICAgIHN1cHBvcnRlZFBhcmFtcyA9IFsnYWNjZXNzX3Rva2VuJywgJ3Rva2VuX3R5cGUnLCAnaWRfdG9rZW4nLCAnY29kZScsICdzdGF0ZScsICdzZXNzaW9uX3N0YXRlJywgJ2V4cGlyZXNfaW4nLCAna2NfYWN0aW9uX3N0YXR1cycsICdrY19hY3Rpb24nLCAnaXNzJ11cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBzdXBwb3J0ZWRQYXJhbXMucHVzaCgnZXJyb3InKVxuICAgIHN1cHBvcnRlZFBhcmFtcy5wdXNoKCdlcnJvcl9kZXNjcmlwdGlvbicpXG4gICAgc3VwcG9ydGVkUGFyYW1zLnB1c2goJ2Vycm9yX3VyaScpXG5cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVybFN0cmluZylcbiAgICBsZXQgcmVkaXJlY3RVcmkgPSAnJ1xuICAgIGxldCBwYXJzZWRcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlTW9kZSA9PT0gJ3F1ZXJ5JyAmJiB1cmwuc2VhcmNoUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICBwYXJzZWQgPSB0aGlzLiNwYXJzZUNhbGxiYWNrUGFyYW1zKHVybC5zZWFyY2gsIHN1cHBvcnRlZFBhcmFtcylcbiAgICAgIHVybC5zZWFyY2ggPSBwYXJzZWQucGFyYW1zU3RyaW5nXG4gICAgICByZWRpcmVjdFVyaSA9IHVybC50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmICh0aGlzLnJlc3BvbnNlTW9kZSA9PT0gJ2ZyYWdtZW50JyAmJiB1cmwuaGFzaC5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJzZWQgPSB0aGlzLiNwYXJzZUNhbGxiYWNrUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSwgc3VwcG9ydGVkUGFyYW1zKVxuICAgICAgdXJsLmhhc2ggPSAnJ1xuICAgICAgcmVkaXJlY3RVcmkgPSB1cmwudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGlmIChwYXJzZWQ/Lm9hdXRoUGFyYW1zKSB7XG4gICAgICBpZiAodGhpcy5mbG93ID09PSAnc3RhbmRhcmQnIHx8IHRoaXMuZmxvdyA9PT0gJ2h5YnJpZCcpIHtcbiAgICAgICAgaWYgKChwYXJzZWQub2F1dGhQYXJhbXMuY29kZSB8fCBwYXJzZWQub2F1dGhQYXJhbXMuZXJyb3IpICYmIHBhcnNlZC5vYXV0aFBhcmFtcy5zdGF0ZSkge1xuICAgICAgICAgIHBhcnNlZC5vYXV0aFBhcmFtcy5yZWRpcmVjdFVyaSA9IHJlZGlyZWN0VXJpXG4gICAgICAgICAgcmV0dXJuIHBhcnNlZC5vYXV0aFBhcmFtc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmxvdyA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICBpZiAoKHBhcnNlZC5vYXV0aFBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyc2VkLm9hdXRoUGFyYW1zLmVycm9yKSAmJiBwYXJzZWQub2F1dGhQYXJhbXMuc3RhdGUpIHtcbiAgICAgICAgICBwYXJzZWQub2F1dGhQYXJhbXMucmVkaXJlY3RVcmkgPSByZWRpcmVjdFVyaVxuICAgICAgICAgIHJldHVybiBwYXJzZWQub2F1dGhQYXJhbXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZWRDYWxsYmFja1BhcmFtc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW1zU3RyaW5nXG4gICAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gb2F1dGhQYXJhbXNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXNTdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc3VwcG9ydGVkUGFyYW1zXG4gICAqIEByZXR1cm5zIHtQYXJzZWRDYWxsYmFja1BhcmFtc31cbiAgICovXG4gICNwYXJzZUNhbGxiYWNrUGFyYW1zIChwYXJhbXNTdHJpbmcsIHN1cHBvcnRlZFBhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zU3RyaW5nKVxuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBvYXV0aFBhcmFtcyA9IHt9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBBcnJheS5mcm9tKHBhcmFtcy5lbnRyaWVzKCkpKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkUGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgb2F1dGhQYXJhbXNba2V5XSA9IHZhbHVlXG4gICAgICAgIHBhcmFtcy5kZWxldGUoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJhbXNTdHJpbmc6IHBhcmFtcy50b1N0cmluZygpLFxuICAgICAgb2F1dGhQYXJhbXNcbiAgICB9XG4gIH1cblxuICBhc3luYyAjcHJvY2Vzc0NhbGxiYWNrIChvYXV0aCkge1xuICAgIGNvbnN0IHsgY29kZSwgZXJyb3IsIHByb21wdCB9ID0gb2F1dGhcbiAgICBsZXQgdGltZUxvY2FsID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcmVmcmVzaFRva2VuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBpZFRva2VuXG4gICAgICovXG4gICAgY29uc3QgYXV0aFN1Y2Nlc3MgPSAoYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgaWRUb2tlbikgPT4ge1xuICAgICAgdGltZUxvY2FsID0gKHRpbWVMb2NhbCArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAvIDJcblxuICAgICAgdGhpcy4jc2V0VG9rZW4oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgaWRUb2tlbiwgdGltZUxvY2FsKVxuXG4gICAgICBpZiAodGhpcy4jdXNlTm9uY2UgJiYgKHRoaXMuaWRUb2tlblBhcnNlZCAmJiB0aGlzLmlkVG9rZW5QYXJzZWQubm9uY2UgIT09IG9hdXRoLnN0b3JlZE5vbmNlKSkge1xuICAgICAgICB0aGlzLiNsb2dJbmZvKCdbS0VZQ0xPQUtdIEludmFsaWQgbm9uY2UsIGNsZWFyaW5nIHRva2VuJylcbiAgICAgICAgdGhpcy5jbGVhclRva2VuKClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vbmNlLicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9hdXRoLmtjX2FjdGlvbl9zdGF0dXMpIHtcbiAgICAgIHRoaXMub25BY3Rpb25VcGRhdGUgJiYgdGhpcy5vbkFjdGlvblVwZGF0ZShvYXV0aC5rY19hY3Rpb25fc3RhdHVzLCBvYXV0aC5rY19hY3Rpb24pXG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpZiAocHJvbXB0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKG9hdXRoLmVycm9yX2Rlc2NyaXB0aW9uICYmIG9hdXRoLmVycm9yX2Rlc2NyaXB0aW9uID09PSAnYXV0aGVudGljYXRpb25fZXhwaXJlZCcpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmxvZ2luKG9hdXRoLmxvZ2luT3B0aW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB7IGVycm9yLCBlcnJvcl9kZXNjcmlwdGlvbjogb2F1dGguZXJyb3JfZGVzY3JpcHRpb24gfVxuICAgICAgICAgIHRoaXMub25BdXRoRXJyb3I/LihlcnJvckRhdGEpXG4gICAgICAgICAgdGhyb3cgZXJyb3JEYXRhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoKHRoaXMuZmxvdyAhPT0gJ3N0YW5kYXJkJykgJiYgKG9hdXRoLmFjY2Vzc190b2tlbiB8fCBvYXV0aC5pZF90b2tlbikpIHtcbiAgICAgIGF1dGhTdWNjZXNzKG9hdXRoLmFjY2Vzc190b2tlbiwgdW5kZWZpbmVkLCBvYXV0aC5pZF90b2tlbilcbiAgICAgIHRoaXMub25BdXRoU3VjY2Vzcz8uKClcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMuZmxvdyAhPT0gJ2ltcGxpY2l0JykgJiYgY29kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFjY2Vzc1Rva2VuKHRoaXMuZW5kcG9pbnRzLnRva2VuKCksIGNvZGUsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jbGllbnRJZCksIG9hdXRoLnJlZGlyZWN0VXJpLCBvYXV0aC5wa2NlQ29kZVZlcmlmaWVyKVxuICAgICAgICBhdXRoU3VjY2VzcyhyZXNwb25zZS5hY2Nlc3NfdG9rZW4sIHJlc3BvbnNlLnJlZnJlc2hfdG9rZW4sIHJlc3BvbnNlLmlkX3Rva2VuKVxuXG4gICAgICAgIGlmICh0aGlzLmZsb3cgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFN1Y2Nlc3M/LigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNzY2hlZHVsZUNoZWNrSWZyYW1lKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMub25BdXRoRXJyb3I/LigpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3NjaGVkdWxlQ2hlY2tJZnJhbWUgKCkge1xuICAgIGlmICh0aGlzLiNsb2dpbklmcmFtZS5lbmFibGUgJiYgdGhpcy50b2tlbikge1xuICAgICAgYXdhaXQgd2FpdEZvclRpbWVvdXQodGhpcy4jbG9naW5JZnJhbWUuaW50ZXJ2YWwgKiAxMDAwKVxuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gYXdhaXQgdGhpcy4jY2hlY2tMb2dpbklmcmFtZSgpXG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jc2NoZWR1bGVDaGVja0lmcmFtZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtMb2dpbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGxvZ2luIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FkYXB0ZXIubG9naW4ob3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWNsb2FrTG9naW5PcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUxvZ2luVXJsIChvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVVVUlEKClcbiAgICBjb25zdCBub25jZSA9IGNyZWF0ZVVVSUQoKVxuICAgIGNvbnN0IHJlZGlyZWN0VXJpID0gdGhpcy4jYWRhcHRlci5yZWRpcmVjdFVyaShvcHRpb25zKVxuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2tTdGF0ZX0gKi9cbiAgICBjb25zdCBjYWxsYmFja1N0YXRlID0ge1xuICAgICAgc3RhdGUsXG4gICAgICBub25jZSxcbiAgICAgIHJlZGlyZWN0VXJpLFxuICAgICAgbG9naW5PcHRpb25zOiBvcHRpb25zXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LnByb21wdCkge1xuICAgICAgY2FsbGJhY2tTdGF0ZS5wcm9tcHQgPSBvcHRpb25zLnByb21wdFxuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IG9wdGlvbnM/LmFjdGlvbiA9PT0gJ3JlZ2lzdGVyJ1xuICAgICAgPyB0aGlzLmVuZHBvaW50cy5yZWdpc3RlcigpXG4gICAgICA6IHRoaXMuZW5kcG9pbnRzLmF1dGhvcml6ZSgpXG5cbiAgICBsZXQgc2NvcGUgPSBvcHRpb25zPy5zY29wZSB8fCB0aGlzLnNjb3BlXG4gICAgY29uc3Qgc2NvcGVWYWx1ZXMgPSBzY29wZSA/IHNjb3BlLnNwbGl0KCcgJykgOiBbXVxuXG4gICAgLy8gRW5zdXJlIHRoZSAnb3BlbmlkJyBzY29wZSBpcyBhbHdheXMgaW5jbHVkZWQuXG4gICAgaWYgKCFzY29wZVZhbHVlcy5pbmNsdWRlcygnb3BlbmlkJykpIHtcbiAgICAgIHNjb3BlVmFsdWVzLnVuc2hpZnQoJ29wZW5pZCcpXG4gICAgfVxuXG4gICAgc2NvcGUgPSBzY29wZVZhbHVlcy5qb2luKCcgJylcblxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICAgICAgWydjbGllbnRfaWQnLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMuY2xpZW50SWQpXSxcbiAgICAgIC8vIFRoZSBlbmRwb2ludCBVUkkgTVVTVCBOT1QgaW5jbHVkZSBhIGZyYWdtZW50IGNvbXBvbmVudC5cbiAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTMuMS4yXG4gICAgICBbJ3JlZGlyZWN0X3VyaScsIHN0cmlwSGFzaChyZWRpcmVjdFVyaSldLFxuICAgICAgWydzdGF0ZScsIHN0YXRlXSxcbiAgICAgIFsncmVzcG9uc2VfbW9kZScsIHRoaXMucmVzcG9uc2VNb2RlXSxcbiAgICAgIFsncmVzcG9uc2VfdHlwZScsIHRoaXMucmVzcG9uc2VUeXBlXSxcbiAgICAgIFsnc2NvcGUnLCBzY29wZV1cbiAgICBdKVxuXG4gICAgaWYgKHRoaXMuI3VzZU5vbmNlKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdub25jZScsIG5vbmNlKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5wcm9tcHQpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ3Byb21wdCcsIG9wdGlvbnMucHJvbXB0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucz8ubWF4QWdlID09PSAnbnVtYmVyJykge1xuICAgICAgcGFyYW1zLmFwcGVuZCgnbWF4X2FnZScsIG9wdGlvbnMubWF4QWdlLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ2luSGludCkge1xuICAgICAgcGFyYW1zLmFwcGVuZCgnbG9naW5faGludCcsIG9wdGlvbnMubG9naW5IaW50KVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5pZHBIaW50KSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdrY19pZHBfaGludCcsIG9wdGlvbnMuaWRwSGludClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uYWN0aW9uICYmIG9wdGlvbnMuYWN0aW9uICE9PSAncmVnaXN0ZXInKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCdrY19hY3Rpb24nLCBvcHRpb25zLmFjdGlvbilcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9jYWxlKSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKCd1aV9sb2NhbGVzJywgb3B0aW9ucy5sb2NhbGUpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmFjcikge1xuICAgICAgcGFyYW1zLmFwcGVuZCgnY2xhaW1zJywgYnVpbGRDbGFpbXNQYXJhbWV0ZXIob3B0aW9ucy5hY3IpKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5hY3JWYWx1ZXMpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ2Fjcl92YWx1ZXMnLCBvcHRpb25zLmFjclZhbHVlcylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wa2NlTWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2RlVmVyaWZpZXIgPSBnZW5lcmF0ZUNvZGVWZXJpZmllcig5NilcbiAgICAgICAgY29uc3QgcGtjZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUGtjZUNoYWxsZW5nZSh0aGlzLnBrY2VNZXRob2QsIGNvZGVWZXJpZmllcilcblxuICAgICAgICBjYWxsYmFja1N0YXRlLnBrY2VDb2RlVmVyaWZpZXIgPSBjb2RlVmVyaWZpZXJcblxuICAgICAgICBwYXJhbXMuYXBwZW5kKCdjb2RlX2NoYWxsZW5nZScsIHBrY2VDaGFsbGVuZ2UpXG4gICAgICAgIHBhcmFtcy5hcHBlbmQoJ2NvZGVfY2hhbGxlbmdlX21ldGhvZCcsIHRoaXMucGtjZU1ldGhvZClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIFBLQ0UgY2hhbGxlbmdlLicsIHsgY2F1c2U6IGVycm9yIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jY2FsbGJhY2tTdG9yYWdlLmFkZChjYWxsYmFja1N0YXRlKVxuXG4gICAgcmV0dXJuIGAke3VybH0/JHtwYXJhbXMudG9TdHJpbmcoKX1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtLZXljbG9ha0xvZ291dE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGxvZ291dCAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiNhZGFwdGVyLmxvZ291dChvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtMb2dvdXRPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZUxvZ291dFVybCAob3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ291dE1ldGhvZCA9IG9wdGlvbnM/LmxvZ291dE1ldGhvZCA/PyB0aGlzLmxvZ291dE1ldGhvZFxuICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnRzLmxvZ291dCgpXG5cbiAgICBpZiAobG9nb3V0TWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICAgIHJldHVybiB1cmxcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAgICAgIFsnY2xpZW50X2lkJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLmNsaWVudElkKV0sXG4gICAgICBbJ3Bvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaScsIHRoaXMuI2FkYXB0ZXIucmVkaXJlY3RVcmkob3B0aW9ucyldXG4gICAgXSlcblxuICAgIGlmICh0aGlzLmlkVG9rZW4pIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoJ2lkX3Rva2VuX2hpbnQnLCB0aGlzLmlkVG9rZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3VybH0/JHtwYXJhbXMudG9TdHJpbmcoKX1gXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtLZXljbG9ha1JlZ2lzdGVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVnaXN0ZXIgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4jYWRhcHRlci5yZWdpc3RlcihvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtSZWdpc3Rlck9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgY3JlYXRlUmVnaXN0ZXJVcmwgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVMb2dpblVybCh7IC4uLm9wdGlvbnMsIGFjdGlvbjogJ3JlZ2lzdGVyJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Y2xvYWtBY2NvdW50T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjcmVhdGVBY2NvdW50VXJsIChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jZ2V0UmVhbG1VcmwoKVxuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBhY2NvdW50IFVSTCwgbWFrZSBzdXJlIHRoZSBhZGFwdGVyIGlzIG5vdCBjb25maWd1cmVkIHVzaW5nIGEgZ2VuZXJpYyBPSURDIHByb3ZpZGVyLicpXG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgICBbJ3JlZmVycmVyJywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLmNsaWVudElkKV0sXG4gICAgICBbJ3JlZmVycmVyX3VyaScsIHRoaXMuI2FkYXB0ZXIucmVkaXJlY3RVcmkob3B0aW9ucyldXG4gICAgXSlcblxuICAgIHJldHVybiBgJHt1cmx9L2FjY291bnQ/JHtwYXJhbXMudG9TdHJpbmcoKX1gXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhY2NvdW50TWFuYWdlbWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FkYXB0ZXIuYWNjb3VudE1hbmFnZW1lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzUmVhbG1Sb2xlIChyb2xlKSB7XG4gICAgY29uc3QgYWNjZXNzID0gdGhpcy5yZWFsbUFjY2Vzc1xuICAgIHJldHVybiAhIWFjY2VzcyAmJiBhY2Nlc3Mucm9sZXMuaW5kZXhPZihyb2xlKSA+PSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXNvdXJjZV1cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNSZXNvdXJjZVJvbGUgKHJvbGUsIHJlc291cmNlKSB7XG4gICAgaWYgKCF0aGlzLnJlc291cmNlQWNjZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBhY2Nlc3MgPSB0aGlzLnJlc291cmNlQWNjZXNzW3Jlc291cmNlIHx8IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jbGllbnRJZCldXG4gICAgcmV0dXJuICEhYWNjZXNzICYmIGFjY2Vzcy5yb2xlcy5pbmRleE9mKHJvbGUpID49IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXljbG9ha1Byb2ZpbGU+fVxuICAgKi9cbiAgYXN5bmMgbG9hZFVzZXJQcm9maWxlICgpIHtcbiAgICBjb25zdCByZWFsbVVybCA9IHRoaXMuI2dldFJlYWxtVXJsKClcblxuICAgIGlmICghcmVhbG1VcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvYWQgdXNlciBwcm9maWxlLCBtYWtlIHN1cmUgdGhlIGFkYXB0ZXIgaXMgbm90IGNvbmZpZ3VyZWQgdXNpbmcgYSBnZW5lcmljIE9JREMgcHJvdmlkZXIuJylcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBgJHtyZWFsbVVybH0vYWNjb3VudGBcbiAgICAvKiogQHR5cGUge0tleWNsb2FrUHJvZmlsZX0gKi9cbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZmV0Y2hKU09OKHVybCwge1xuICAgICAgaGVhZGVyczogW2J1aWxkQXV0aG9yaXphdGlvbkhlYWRlcih0aGlzLnRva2VuKV1cbiAgICB9KVxuXG4gICAgcmV0dXJuICh0aGlzLnByb2ZpbGUgPSBwcm9maWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHt9Pn1cbiAgICovXG4gIGFzeW5jIGxvYWRVc2VySW5mbyAoKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5lbmRwb2ludHMudXNlcmluZm8oKVxuICAgIC8qKiBAdHlwZSB7e319ICovXG4gICAgY29uc3QgdXNlckluZm8gPSBhd2FpdCBmZXRjaEpTT04odXJsLCB7XG4gICAgICBoZWFkZXJzOiBbYnVpbGRBdXRob3JpemF0aW9uSGVhZGVyKHRoaXMudG9rZW4pXVxuICAgIH0pXG5cbiAgICByZXR1cm4gKHRoaXMudXNlckluZm8gPSB1c2VySW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pblZhbGlkaXR5XVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzVG9rZW5FeHBpcmVkIChtaW5WYWxpZGl0eSkge1xuICAgIGlmICghdGhpcy50b2tlblBhcnNlZCB8fCAoIXRoaXMucmVmcmVzaFRva2VuICYmIHRoaXMuZmxvdyAhPT0gJ2ltcGxpY2l0JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVTa2V3ID09IG51bGwpIHtcbiAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gVW5hYmxlIHRvIGRldGVybWluZSBpZiB0b2tlbiBpcyBleHBpcmVkIGFzIHRpbWVza2V3IGlzIG5vdCBzZXQnKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMudG9rZW5QYXJzZWQuZXhwICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgbGV0IGV4cGlyZXNJbiA9IHRoaXMudG9rZW5QYXJzZWQuZXhwIC0gTWF0aC5jZWlsKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyB0aGlzLnRpbWVTa2V3XG4gICAgaWYgKG1pblZhbGlkaXR5KSB7XG4gICAgICBpZiAoaXNOYU4obWluVmFsaWRpdHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtaW5WYWxpZGl0eScpXG4gICAgICB9XG4gICAgICBleHBpcmVzSW4gLT0gbWluVmFsaWRpdHlcbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyZXNJbiA8IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluVmFsaWRpdHlcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyB1cGRhdGVUb2tlbiAobWluVmFsaWRpdHkpIHtcbiAgICBpZiAoIXRoaXMucmVmcmVzaFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB1cGRhdGUgdG9rZW4sIG5vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlLicpXG4gICAgfVxuXG4gICAgbWluVmFsaWRpdHkgPSBtaW5WYWxpZGl0eSB8fCA1XG5cbiAgICBpZiAodGhpcy4jbG9naW5JZnJhbWUuZW5hYmxlKSB7XG4gICAgICBhd2FpdCB0aGlzLiNjaGVja0xvZ2luSWZyYW1lKClcbiAgICB9XG5cbiAgICBsZXQgcmVmcmVzaFRva2VuID0gZmFsc2VcblxuICAgIGlmIChtaW5WYWxpZGl0eSA9PT0gLTEpIHtcbiAgICAgIHJlZnJlc2hUb2tlbiA9IHRydWVcbiAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gUmVmcmVzaGluZyB0b2tlbjogZm9yY2VkIHJlZnJlc2gnKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMudG9rZW5QYXJzZWQgfHwgdGhpcy5pc1Rva2VuRXhwaXJlZChtaW5WYWxpZGl0eSkpIHtcbiAgICAgIHJlZnJlc2hUb2tlbiA9IHRydWVcbiAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gUmVmcmVzaGluZyB0b2tlbjogdG9rZW4gZXhwaXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7UHJvbWlzZVdpdGhSZXNvbHZlcnM8Ym9vbGVhbj59ICovXG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpXG5cbiAgICB0aGlzLiNyZWZyZXNoUXVldWUucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KVxuXG4gICAgaWYgKHRoaXMuI3JlZnJlc2hRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuZW5kcG9pbnRzLnRva2VuKClcbiAgICAgIGxldCB0aW1lTG9jYWwgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoUmVmcmVzaFRva2VuKHVybCwgdGhpcy5yZWZyZXNoVG9rZW4sIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jbGllbnRJZCkpXG4gICAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gVG9rZW4gcmVmcmVzaGVkJylcblxuICAgICAgICB0aW1lTG9jYWwgPSAodGltZUxvY2FsICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpIC8gMlxuXG4gICAgICAgIHRoaXMuI3NldFRva2VuKHJlc3BvbnNlLmFjY2Vzc190b2tlbiwgcmVzcG9uc2UucmVmcmVzaF90b2tlbiwgcmVzcG9uc2UuaWRfdG9rZW4sIHRpbWVMb2NhbClcblxuICAgICAgICB0aGlzLm9uQXV0aFJlZnJlc2hTdWNjZXNzPy4oKVxuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy4jcmVmcmVzaFF1ZXVlLnBvcCgpOyBwICE9IG51bGw7IHAgPSB0aGlzLiNyZWZyZXNoUXVldWUucG9wKCkpIHtcbiAgICAgICAgICBwLnJlc29sdmUodHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy4jbG9nV2FybignW0tFWUNMT0FLXSBGYWlsZWQgdG8gcmVmcmVzaCB0b2tlbicpXG5cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTmV0d29ya0Vycm9yICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclRva2VuKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25BdXRoUmVmcmVzaEVycm9yPy4oKVxuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy4jcmVmcmVzaFF1ZXVlLnBvcCgpOyBwICE9IG51bGw7IHAgPSB0aGlzLiNyZWZyZXNoUXVldWUucG9wKCkpIHtcbiAgICAgICAgICBwLnJlamVjdChlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlXG4gIH1cblxuICBjbGVhclRva2VuICgpIHtcbiAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgdGhpcy4jc2V0VG9rZW4oKVxuICAgICAgdGhpcy5vbkF1dGhMb2dvdXQ/LigpXG4gICAgICBpZiAodGhpcy5sb2dpblJlcXVpcmVkKSB7XG4gICAgICAgIHRoaXMubG9naW4oKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Rva2VuXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JlZnJlc2hUb2tlbl1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpZFRva2VuXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVMb2NhbF1cbiAgICovXG4gICNzZXRUb2tlbiAodG9rZW4sIHJlZnJlc2hUb2tlbiwgaWRUb2tlbiwgdGltZUxvY2FsKSB7XG4gICAgaWYgKHRoaXMudG9rZW5UaW1lb3V0SGFuZGxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50b2tlblRpbWVvdXRIYW5kbGUpXG4gICAgICB0aGlzLnRva2VuVGltZW91dEhhbmRsZSA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuXG4gICAgICB0aGlzLnJlZnJlc2hUb2tlblBhcnNlZCA9IGRlY29kZVRva2VuKHJlZnJlc2hUb2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMucmVmcmVzaFRva2VuXG4gICAgICBkZWxldGUgdGhpcy5yZWZyZXNoVG9rZW5QYXJzZWRcbiAgICB9XG5cbiAgICBpZiAoaWRUb2tlbikge1xuICAgICAgdGhpcy5pZFRva2VuID0gaWRUb2tlblxuICAgICAgdGhpcy5pZFRva2VuUGFyc2VkID0gZGVjb2RlVG9rZW4oaWRUb2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuaWRUb2tlblxuICAgICAgZGVsZXRlIHRoaXMuaWRUb2tlblBhcnNlZFxuICAgIH1cblxuICAgIGlmICh0b2tlbikge1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB0aGlzLnRva2VuUGFyc2VkID0gZGVjb2RlVG9rZW4odG9rZW4pXG4gICAgICB0aGlzLnNlc3Npb25JZCA9IHRoaXMudG9rZW5QYXJzZWQuc2lkXG4gICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSB0cnVlXG4gICAgICB0aGlzLnN1YmplY3QgPSB0aGlzLnRva2VuUGFyc2VkLnN1YlxuICAgICAgdGhpcy5yZWFsbUFjY2VzcyA9IHRoaXMudG9rZW5QYXJzZWQucmVhbG1fYWNjZXNzXG4gICAgICB0aGlzLnJlc291cmNlQWNjZXNzID0gdGhpcy50b2tlblBhcnNlZC5yZXNvdXJjZV9hY2Nlc3NcblxuICAgICAgaWYgKHRpbWVMb2NhbCkge1xuICAgICAgICB0aGlzLnRpbWVTa2V3ID0gTWF0aC5mbG9vcih0aW1lTG9jYWwgLyAxMDAwKSAtIHRoaXMudG9rZW5QYXJzZWQuaWF0XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRpbWVTa2V3ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gRXN0aW1hdGVkIHRpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXIgYW5kIHNlcnZlciBpcyAnICsgdGhpcy50aW1lU2tldyArICcgc2Vjb25kcycpXG5cbiAgICAgICAgaWYgKHRoaXMub25Ub2tlbkV4cGlyZWQpIHtcbiAgICAgICAgICBjb25zdCBleHBpcmVzSW4gPSAodGhpcy50b2tlblBhcnNlZC5leHAgLSAobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIHRoaXMudGltZVNrZXcpICogMTAwMFxuICAgICAgICAgIHRoaXMuI2xvZ0luZm8oJ1tLRVlDTE9BS10gVG9rZW4gZXhwaXJlcyBpbiAnICsgTWF0aC5yb3VuZChleHBpcmVzSW4gLyAxMDAwKSArICcgcycpXG4gICAgICAgICAgaWYgKGV4cGlyZXNJbiA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG9rZW5FeHBpcmVkKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlblRpbWVvdXRIYW5kbGUgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLm9uVG9rZW5FeHBpcmVkLCBleHBpcmVzSW4pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRva2VuXG4gICAgICBkZWxldGUgdGhpcy50b2tlblBhcnNlZFxuICAgICAgZGVsZXRlIHRoaXMuc3ViamVjdFxuICAgICAgZGVsZXRlIHRoaXMucmVhbG1BY2Nlc3NcbiAgICAgIGRlbGV0ZSB0aGlzLnJlc291cmNlQWNjZXNzXG5cbiAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmc9fVxuICAgKi9cbiAgI2dldFJlYWxtVXJsICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuYXV0aFNlcnZlclVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiBgJHtzdHJpcFRyYWlsaW5nU2xhc2godGhpcy5hdXRoU2VydmVyVXJsKX0vcmVhbG1zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5yZWFsbSkpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJucyB7KG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZH1cbiAgICovXG4gICNjcmVhdGVMb2dnZXIgKGZuKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5lbmFibGVMb2dnaW5nKSB7XG4gICAgICAgIGZuLmNhbGwoY29uc29sZSwgbWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjcmVhdGVVVUlEICgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYiBDcnlwdG8gQVBJIGlzIG5vdCBhdmFpbGFibGUuJylcbiAgfVxuXG4gIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBY3J9IHJlcXVlc3RlZEFjclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVpbGRDbGFpbXNQYXJhbWV0ZXIgKHJlcXVlc3RlZEFjcikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGlkX3Rva2VuOiB7XG4gICAgICBhY3I6IHJlcXVlc3RlZEFjclxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVWZXJpZmllciAobGVuKSB7XG4gIHJldHVybiBnZW5lcmF0ZVJhbmRvbVN0cmluZyhsZW4sICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OScpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrY2VNZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlVmVyaWZpZXJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUGtjZUNoYWxsZW5nZSAocGtjZU1ldGhvZCwgY29kZVZlcmlmaWVyKSB7XG4gIGlmIChwa2NlTWV0aG9kICE9PSAnUzI1NicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAncGtjZU1ldGhvZCcsIGV4cGVjdGVkICdTMjU2JyBidXQgZ290ICcke3BrY2VNZXRob2R9Jy5gKVxuICB9XG5cbiAgLy8gaGFzaCBjb2RlVmVyaWZpZXIsIHRoZW4gZW5jb2RlIGFzIHVybC1zYWZlIGJhc2U2NCB3aXRob3V0IHBhZGRpbmdcbiAgY29uc3QgaGFzaEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgc2hhMjU2RGlnZXN0KGNvZGVWZXJpZmllcikpXG4gIGNvbnN0IGVuY29kZWRIYXNoID0gYnl0ZXNUb0Jhc2U2NChoYXNoQnl0ZXMpXG4gICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgLnJlcGxhY2UoLz0vZywgJycpXG5cbiAgcmV0dXJuIGVuY29kZWRIYXNoXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZyAobGVuLCBhbHBoYWJldCkge1xuICBjb25zdCByYW5kb21EYXRhID0gZ2VuZXJhdGVSYW5kb21EYXRhKGxlbilcbiAgY29uc3QgY2hhcnMgPSBuZXcgQXJyYXkobGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBhbHBoYWJldC5jaGFyQ29kZUF0KHJhbmRvbURhdGFbaV0gJSBhbHBoYWJldC5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2hhcnMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybnMge1VpbnQ4QXJyYXk8QXJyYXlCdWZmZXI+fVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbURhdGEgKGxlbikge1xuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWIgQ3J5cHRvIEFQSSBpcyBub3QgYXZhaWxhYmxlLicpXG4gIH1cblxuICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW4pKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGV4dGVuZCBleGlzdGluZyBuYXRpdmUgUHJvbWlzZSB3aXRoIHRpbWVvdXRcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yTWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8VD59XG4gKi9cbmZ1bmN0aW9uIGFwcGx5VGltZW91dFRvUHJvbWlzZSAocHJvbWlzZSwgdGltZW91dCwgZXJyb3JNZXNzYWdlKSB7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBsZXQgdGltZW91dEhhbmRsZVxuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aW1lb3V0SGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgfHwgJ1Byb21pc2UgaXMgbm90IHNldHRsZWQgd2l0aGluIHRpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMnKSlcbiAgICB9LCB0aW1lb3V0KVxuICB9KVxuXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpXG4gIH0pXG59XG5cbi8qKlxuICogQHJldHVybnMge0NhbGxiYWNrU3RvcmFnZX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tTdG9yYWdlICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IExvY2FsU3RvcmFnZSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgQ29va2llU3RvcmFnZSgpXG4gIH1cbn1cblxuY29uc3QgU1RPUkFHRV9LRVlfUFJFRklYID0gJ2tjLWNhbGxiYWNrLSdcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYWxsYmFja1N0YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBub25jZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlZGlyZWN0VXJpXG4gKiBAcHJvcGVydHkge0tleWNsb2FrTG9naW5PcHRpb25zfSBbbG9naW5PcHRpb25zXVxuICogQHByb3BlcnR5IHtLZXljbG9ha0xvZ2luT3B0aW9uc1sncHJvbXB0J119IFtwcm9tcHRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BrY2VDb2RlVmVyaWZpZXJdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYWxsYmFja1N0b3JhZ2VcbiAqIEBwcm9wZXJ0eSB7KHN0YXRlPzogc3RyaW5nKSA9PiBDYWxsYmFja1N0YXRlIHwgbnVsbH0gZ2V0XG4gKiBAcHJvcGVydHkgeyhzdGF0ZTogQ2FsbGJhY2tTdGF0ZSkgPT4gdm9pZH0gYWRkXG4gKi9cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7Q2FsbGJhY2tTdG9yYWdlfVxuICovXG5jbGFzcyBMb2NhbFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgna2MtdGVzdCcsICd0ZXN0JylcbiAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdrYy10ZXN0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXRlXVxuICAgKiBAcmV0dXJucyB7Q2FsbGJhY2tTdGF0ZSB8IG51bGx9XG4gICAqL1xuICBnZXQgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0aGlzLiNjbGVhckludmFsaWRWYWx1ZXMoKVxuXG4gICAgY29uc3Qga2V5ID0gU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGVcbiAgICBjb25zdCB2YWx1ZSA9IGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2tTdGF0ZX0gc3RhdGVcbiAgICovXG4gIGFkZCAoc3RhdGUpIHtcbiAgICB0aGlzLiNjbGVhckludmFsaWRWYWx1ZXMoKVxuXG4gICAgY29uc3Qga2V5ID0gU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGUuc3RhdGVcbiAgICBjb25zdCB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLy8gU2V0IHRoZSBleHBpcnkgdGltZSB0byAxIGhvdXIgZnJvbSBub3cuXG4gICAgICBleHBpcmVzOiBEYXRlLm5vdygpICsgKDYwICogNjAgKiAxMDAwKVxuICAgIH0pXG5cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgc3RvcmFnZSBpcyBmdWxsLCBjbGVhciBhbGwga25vd24gdmFsdWVzIGFuZCB0cnkgYWdhaW4uXG4gICAgICB0aGlzLiNjbGVhckFsbFZhbHVlcygpXG4gICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIHZhbHVlcyBmcm9tIGxvY2FsIHN0b3JhZ2UgdGhhdCBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuICAgKi9cbiAgI2NsZWFySW52YWxpZFZhbHVlcyAoKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNnZXRTdG9yZWRFbnRyaWVzKCkpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGV4cGlyeSB0aW1lIGZyb20gdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZXhwaXJ5ID0gdGhpcy4jcGFyc2VFeHBpcnkodmFsdWUpXG5cbiAgICAgIC8vIERpc2NhcmQgdGhlIHZhbHVlIGlmIGl0IGlzIG1hbGZvcm1lZCBvciBleHBpcmVkLlxuICAgICAgaWYgKGV4cGlyeSA9PT0gbnVsbCB8fCBleHBpcnkgPCBjdXJyZW50VGltZSkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBrbm93biB2YWx1ZXMgZnJvbSBsb2NhbCBzdG9yYWdlLlxuICAgKi9cbiAgI2NsZWFyQWxsVmFsdWVzICgpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXldIG9mIHRoaXMuI2dldFN0b3JlZEVudHJpZXMoKSkge1xuICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIGVudHJpZXMgc3RvcmVkIGluIGxvY2FsIHN0b3JhZ2UgdGhhdCBhcmUga25vd24gdG8gYmUgbWFuYWdlZCBieSB0aGlzIGNsYXNzLlxuICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXVtdfSBBbiBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICAjZ2V0U3RvcmVkRW50cmllcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlKS5maWx0ZXIoKFtrZXldKSA9PiBrZXkuc3RhcnRzV2l0aChTVE9SQUdFX0tFWV9QUkVGSVgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZXhwaXJ5IHRpbWUgZnJvbSBhIHZhbHVlIHN0b3JlZCBpbiBsb2NhbCBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybnMge251bWJlciB8IG51bGx9IFRoZSBleHBpcnkgdGltZSBpbiBtaWxsaXNlY29uZHMsIG9yIGBudWxsYCBpZiB0aGUgdmFsdWUgaXMgbWFsZm9ybWVkLlxuICAgKi9cbiAgI3BhcnNlRXhwaXJ5ICh2YWx1ZSkge1xuICAgIGxldCBwYXJzZWRWYWx1ZVxuXG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgdmFsdWUgYXMgSlNPTi5cbiAgICB0cnkge1xuICAgICAgcGFyc2VkVmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIEF0dGVtcHQgdG8gZXh0cmFjdCB0aGUgJ2V4cGlyZXMnIHByb3BlcnR5LlxuICAgIGlmIChpc09iamVjdChwYXJzZWRWYWx1ZSkgJiYgJ2V4cGlyZXMnIGluIHBhcnNlZFZhbHVlICYmIHR5cGVvZiBwYXJzZWRWYWx1ZS5leHBpcmVzID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlLmV4cGlyZXNcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMge0NhbGxiYWNrU3RvcmFnZX1cbiAqL1xuY2xhc3MgQ29va2llU3RvcmFnZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0YXRlXVxuICAgKiBAcmV0dXJucyB7Q2FsbGJhY2tTdGF0ZSB8IG51bGx9XG4gICAqL1xuICBnZXQgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2dldENvb2tpZShTVE9SQUdFX0tFWV9QUkVGSVggKyBzdGF0ZSlcbiAgICB0aGlzLiNzZXRDb29raWUoU1RPUkFHRV9LRVlfUFJFRklYICsgc3RhdGUsICcnLCB0aGlzLiNjb29raWVFeHBpcmF0aW9uKC0xMDApKVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbGxiYWNrU3RhdGV9IHN0YXRlXG4gICAqL1xuICBhZGQgKHN0YXRlKSB7XG4gICAgdGhpcy4jc2V0Q29va2llKFNUT1JBR0VfS0VZX1BSRUZJWCArIHN0YXRlLnN0YXRlLCBKU09OLnN0cmluZ2lmeShzdGF0ZSksIHRoaXMuI2Nvb2tpZUV4cGlyYXRpb24oNjApKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gICNnZXRDb29raWUgKGtleSkge1xuICAgIGNvbnN0IG5hbWUgPSBrZXkgKyAnPSdcbiAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGMgPSBjYVtpXVxuICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEpXG4gICAgICB9XG4gICAgICBpZiAoYy5pbmRleE9mKG5hbWUpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lLmxlbmd0aCwgYy5sZW5ndGgpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZXhwaXJhdGlvbkRhdGVcbiAgICovXG4gICNzZXRDb29raWUgKGtleSwgdmFsdWUsIGV4cGlyYXRpb25EYXRlKSB7XG4gICAgY29uc3QgY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgKyAnOyAnICtcbiAgICAgICAgICAgICdleHBpcmVzPScgKyBleHBpcmF0aW9uRGF0ZS50b1VUQ1N0cmluZygpICsgJzsgJ1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51dGVzXG4gICAqIEByZXR1cm5zIHtEYXRlfVxuICAgKi9cbiAgI2Nvb2tpZUV4cGlyYXRpb24gKG1pbnV0ZXMpIHtcbiAgICBjb25zdCBleHAgPSBuZXcgRGF0ZSgpXG4gICAgZXhwLnNldFRpbWUoZXhwLmdldFRpbWUoKSArIChtaW51dGVzICogNjAgKiAxMDAwKSlcbiAgICByZXR1cm4gZXhwXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXk8QXJyYXlCdWZmZXI+fSBieXRlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCN0aGVfdW5pY29kZV9wcm9ibGVtXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQgKGJ5dGVzKSB7XG4gIGNvbnN0IGJpblN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmJ5dGVzKVxuICByZXR1cm4gYnRvYShiaW5TdHJpbmcpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kaWdlc3QjYmFzaWNfZXhhbXBsZVxuICovXG5hc3luYyBmdW5jdGlvbiBzaGEyNTZEaWdlc3QgKG1lc3NhZ2UpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4gIGNvbnN0IGRhdGEgPSBlbmNvZGVyLmVuY29kZShtZXNzYWdlKVxuXG4gIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgY3J5cHRvLnN1YnRsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYiBDcnlwdG8gQVBJIGlzIG5vdCBhdmFpbGFibGUuJylcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGRhdGEpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJucyB7S2V5Y2xvYWtUb2tlblBhcnNlZH1cbiAqL1xuZnVuY3Rpb24gZGVjb2RlVG9rZW4gKHRva2VuKSB7XG4gIGNvbnN0IFssIHBheWxvYWRdID0gdG9rZW4uc3BsaXQoJy4nKVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgdG9rZW4sIHBheWxvYWQgbm90IGZvdW5kLicpXG4gIH1cblxuICBsZXQgZGVjb2RlZFxuXG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IGJhc2U2NFVybERlY29kZShwYXlsb2FkKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY29kZSB0b2tlbiwgcGF5bG9hZCBpcyBub3QgYSB2YWxpZCBCYXNlNjRVUkwgdmFsdWUuJywgeyBjYXVzZTogZXJyb3IgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgdG9rZW4sIHBheWxvYWQgaXMgbm90IGEgdmFsaWQgSlNPTiB2YWx1ZS4nLCB7IGNhdXNlOiBlcnJvciB9KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFVybERlY29kZSAoaW5wdXQpIHtcbiAgbGV0IG91dHB1dCA9IGlucHV0XG4gICAgLnJlcGxhY2VBbGwoJy0nLCAnKycpXG4gICAgLnJlcGxhY2VBbGwoJ18nLCAnLycpXG5cbiAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOlxuICAgICAgb3V0cHV0ICs9ICc9PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAzOlxuICAgICAgb3V0cHV0ICs9ICc9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLicpXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBiNjREZWNvZGVVbmljb2RlKG91dHB1dClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXRvYihvdXRwdXQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqL1xuZnVuY3Rpb24gYjY0RGVjb2RlVW5pY29kZSAoaW5wdXQpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhdG9iKGlucHV0KS5yZXBsYWNlKC8oLikvZywgKG0sIHApID0+IHtcbiAgICBsZXQgY29kZSA9IHAuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuXG4gICAgaWYgKGNvZGUubGVuZ3RoIDwgMikge1xuICAgICAgY29kZSA9ICcwJyArIGNvZGVcbiAgICB9XG5cbiAgICByZXR1cm4gJyUnICsgY29kZVxuICB9KSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIG9wZXJhdGVkIG9uLlxuICogQHBhcmFtIHt1bmtub3dufSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc09iamVjdCAoaW5wdXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQgIT09IG51bGxcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBKc29uQ29uZmlnIFRoZSBKU09OIHZlcnNpb24gb2YgdGhlIGFkYXB0ZXIgY29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoLXNlcnZlci11cmwgVGhlIFVSTCBvZiB0aGUgYXV0aGVudGljYXRpb24gc2VydmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlYWxtIFRoZSBuYW1lIG9mIHRoZSByZWFsbS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNvdXJjZSBUaGUgbmFtZSBvZiB0aGUgcmVzb3VyY2UsIHVzdWFsbHkgdGhlIGNsaWVudCBJRC5cbiAqL1xuXG4vKipcbiAqIEZldGNoIHRoZSBhZGFwdGVyIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge1Byb21pc2U8SnNvbkNvbmZpZz59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoSnNvbkNvbmZpZyAodXJsKSB7XG4gIHJldHVybiBhd2FpdCBmZXRjaEpTT04odXJsKVxufVxuXG4vKipcbiAqIEZldGNoIHRoZSBPcGVuSUQgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBnaXZlbiBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPcGVuSWRQcm92aWRlck1ldGFkYXRhPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hPcGVuSWRDb25maWcgKHVybCkge1xuICByZXR1cm4gYXdhaXQgZmV0Y2hKU09OKHVybClcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBY2Nlc3NUb2tlblJlc3BvbnNlIFRoZSBzdWNjZXNzZnVsIHRva2VuIHJlc3BvbnNlIGZyb20gdGhlIGF1dGhvcml6YXRpb24gc2VydmVyLCBiYXNlZCBvbiB0aGUge0BsaW5rIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjc0OSNzZWN0aW9uLTUuMSBPQXV0aCAyLjAgQXV0aG9yaXphdGlvbiBGcmFtZXdvcmsgc3BlY2lmaWNhdGlvbn0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWNjZXNzX3Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gaXNzdWVkIGJ5IHRoZSBhdXRob3JpemF0aW9uIHNlcnZlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0b2tlbl90eXBlIFRoZSB0eXBlIG9mIHRoZSB0b2tlbiBpc3N1ZWQgYnkgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtleHBpcmVzX2luXSBUaGUgbGlmZXRpbWUgaW4gc2Vjb25kcyBvZiB0aGUgYWNjZXNzIHRva2VuLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZWZyZXNoX3Rva2VuXSBUaGUgcmVmcmVzaCB0b2tlbiBpc3N1ZWQgYnkgdGhlIGF1dGhvcml6YXRpb24gc2VydmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF90b2tlbl0gVGhlIElEIHRva2VuIGlzc3VlZCBieSB0aGUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIsIGlmIHJlcXVlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2NvcGVdIFRoZSBzY29wZSBvZiB0aGUgYWNjZXNzIHRva2VuLlxuICovXG5cbi8qKlxuICogRmV0Y2ggdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBnaXZlbiBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudElkXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVkaXJlY3RVcmlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGtjZUNvZGVWZXJpZmllcl1cbiAqIEByZXR1cm5zIHtQcm9taXNlPEFjY2Vzc1Rva2VuUmVzcG9uc2U+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFjY2Vzc1Rva2VuICh1cmwsIGNvZGUsIGNsaWVudElkLCByZWRpcmVjdFVyaSwgcGtjZUNvZGVWZXJpZmllcikge1xuICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgWydjb2RlJywgY29kZV0sXG4gICAgWydncmFudF90eXBlJywgJ2F1dGhvcml6YXRpb25fY29kZSddLFxuICAgIFsnY2xpZW50X2lkJywgY2xpZW50SWRdLFxuICAgIFsncmVkaXJlY3RfdXJpJywgc3RyaXBIYXNoKHJlZGlyZWN0VXJpKV1cbiAgXSlcblxuICBpZiAocGtjZUNvZGVWZXJpZmllcikge1xuICAgIGJvZHkuYXBwZW5kKCdjb2RlX3ZlcmlmaWVyJywgcGtjZUNvZGVWZXJpZmllcilcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBmZXRjaEpTT04odXJsLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBib2R5XG4gIH0pXG59XG5cbi8qKlxuICogRmV0Y2ggdGhlIHJlZnJlc2ggdG9rZW4gZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZnJlc2hUb2tlblxuICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudElkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBY2Nlc3NUb2tlblJlc3BvbnNlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWZyZXNoVG9rZW4gKHVybCwgcmVmcmVzaFRva2VuLCBjbGllbnRJZCkge1xuICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gICAgWydncmFudF90eXBlJywgJ3JlZnJlc2hfdG9rZW4nXSxcbiAgICBbJ3JlZnJlc2hfdG9rZW4nLCByZWZyZXNoVG9rZW5dLFxuICAgIFsnY2xpZW50X2lkJywgY2xpZW50SWRdXG4gIF0pXG5cbiAgcmV0dXJuIGF3YWl0IGZldGNoSlNPTih1cmwsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGJvZHlcbiAgfSlcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9dW5rbm93bl1cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7UmVxdWVzdEluaXR9IGluaXRcbiAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaEpTT04gKHVybCwgaW5pdCA9IHt9KSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpXG4gIGhlYWRlcnMuc2V0KCdBY2NlcHQnLCBDT05URU5UX1RZUEVfSlNPTilcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEVycm9ySGFuZGxpbmcodXJsLCB7XG4gICAgLi4uaW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pXG5cbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7UmVxdWVzdEluaXR9IFtpbml0XVxuICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhFcnJvckhhbmRsaW5nICh1cmwsIGluaXQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpXG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBOZXR3b3JrRXJyb3IoJ1NlcnZlciByZXNwb25kZWQgd2l0aCBhbiBpbnZhbGlkIHN0YXR1cy4nLCB7IHJlc3BvbnNlIH0pXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Rva2VuXVxuICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQXV0aG9yaXphdGlvbkhlYWRlciAodG9rZW4pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGJ1aWxkIGF1dGhvcml6YXRpb24gaGVhZGVyLCB0b2tlbiBpcyBub3Qgc2V0LCBtYWtlIHN1cmUgdGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZC4nKVxuICB9XG5cbiAgcmV0dXJuIFsnQXV0aG9yaXphdGlvbicsIGBiZWFyZXIgJHt0b2tlbn1gXVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaCAodXJsKSB7XG4gIHJldHVybiB1cmwuZW5kc1dpdGgoJy8nKSA/IHVybC5zbGljZSgwLCAtMSkgOiB1cmxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpcEhhc2ggKHVybCkge1xuICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybClcbiAgcGFyc2VkVXJsLmhhc2ggPSAnJ1xuICByZXR1cm4gcGFyc2VkVXJsLnRvU3RyaW5nKClcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBOZXR3b3JrRXJyb3JPcHRpb25zUHJvcGVydGllc1xuICogQHByb3BlcnR5IHtSZXNwb25zZX0gcmVzcG9uc2VcbiAqIEB0eXBlZGVmIHtFcnJvck9wdGlvbnMgJiBOZXR3b3JrRXJyb3JPcHRpb25zUHJvcGVydGllc30gTmV0d29ya0Vycm9yT3B0aW9uc1xuICovXG5cbmV4cG9ydCBjbGFzcyBOZXR3b3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAdHlwZSB7UmVzcG9uc2V9ICovXG4gIHJlc3BvbnNlXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7TmV0d29ya0Vycm9yT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKVxuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCB3YWl0Rm9yVGltZW91dCA9IChkZWxheSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/keycloak-js/lib/keycloak.js\n");

/***/ })

};
;